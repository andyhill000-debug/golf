<!DOCTYPE html>
<html lang="en">
<head>
<meta name="app-version" content="2026.02.25.7"/>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="manifest" href="manifest.json"/>
<meta name="theme-color" content="#0a0a0a"/>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
<title>Hillfred Golf Â· Live Leaderboard</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,700;0,900;1,700&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet"/>
<style>
:root{
  --teal:#00e8bb; --gold:#e2b84a; --red:#ff5a5a;
  --bg:#0a0a0a; --card:#141414; --border:#1e1e1e;
  --text:#f0f0f0; --muted:#555;
  --row-h:72px;
}
*{box-sizing:border-box;margin:0;padding:0;}
body{background:var(--bg);color:var(--text);font-family:'DM Sans',sans-serif;min-height:100vh;-webkit-font-smoothing:antialiased;}

/* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.header{background:#080808;border-bottom:1px solid var(--border);padding:12px 20px;display:flex;align-items:center;justify-content:space-between;position:sticky;top:0;z-index:200;}
.header-left{display:flex;align-items:center;gap:12px;}
.back-btn{display:flex;align-items:center;gap:5px;background:rgba(0,232,187,.07);border:1.5px solid rgba(0,232,187,.2);border-radius:8px;color:var(--teal);font-family:'DM Sans',sans-serif;font-size:12px;font-weight:700;padding:6px 11px;text-decoration:none;transition:background .15s;letter-spacing:.3px;cursor:pointer;}
.back-btn:hover{background:rgba(0,232,187,.13);}
.header-brand{font-family:'Playfair Display',serif;font-size:18px;font-weight:900;letter-spacing:-.3px;}
.header-brand span{color:var(--teal);}
.live-badge{display:flex;align-items:center;gap:6px;font-size:11px;font-weight:700;letter-spacing:1.5px;color:var(--teal);}
.live-dot{width:8px;height:8px;border-radius:50%;background:var(--teal);animation:blink 1.8s ease infinite;}
.live-dot.off{background:var(--red);animation:none;}
@keyframes blink{0%,100%{opacity:1;}50%{opacity:.3;}}
.refresh-btn{display:flex;align-items:center;justify-content:center;width:32px;height:32px;background:rgba(0,232,187,.07);border:1.5px solid rgba(0,232,187,.2);border-radius:8px;color:var(--teal);font-size:15px;cursor:pointer;transition:background .15s,transform .3s;-webkit-tap-highlight-color:transparent;}
.refresh-btn:hover{background:rgba(0,232,187,.13);}
.refresh-btn.spinning{animation:spin .7s linear;}
@keyframes spin{from{transform:rotate(0deg);}to{transform:rotate(360deg);}}
.match-progress-bar{background:#080808;border-bottom:1px solid var(--border);padding:10px 20px;display:none;}
.match-progress-bar.visible{display:block;}
.mp-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;}
.mp-label{font-size:11px;font-weight:700;letter-spacing:1px;color:#ccc;text-transform:uppercase;}
.mp-count{font-size:13px;font-weight:900;}
.mp-track{height:5px;background:#1e1e1e;border-radius:3px;overflow:hidden;}
.mp-fill{height:100%;background:var(--teal);border-radius:3px;transition:width .5s ease;}
.offline-bar{background:rgba(255,90,90,.08);border-bottom:1px solid rgba(255,90,90,.2);padding:8px 20px;display:none;align-items:center;justify-content:space-between;gap:10px;}
.offline-bar.visible{display:flex;}
.offline-msg{font-size:12px;color:#ff5a5a;font-weight:700;letter-spacing:.3px;}
.reconnect-btn{padding:5px 12px;background:rgba(255,90,90,.12);border:1.5px solid rgba(255,90,90,.3);border-radius:7px;color:#ff5a5a;font-family:'DM Sans',sans-serif;font-size:11px;font-weight:700;cursor:pointer;white-space:nowrap;-webkit-tap-highlight-color:transparent;}
.reconnect-btn:active{background:rgba(255,90,90,.25);}

/* â”€â”€ Live banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#live-banner{background:linear-gradient(180deg,#0d0d0d 0%,#080808 100%);border-bottom:2px solid var(--border);overflow:hidden;transition:height .4s ease;}
.banner-inner{max-width:960px;margin:0 auto;padding:0 20px;}

/* Individual banner */
.banner-title{font-size:9px;font-weight:700;letter-spacing:2px;color:var(--muted);text-transform:uppercase;padding:10px 0 6px;}
.banner-rail{position:relative;} /* height set by JS */
.banner-row{
  position:absolute; left:0; right:0; height:var(--row-h);
  display:flex; align-items:center; gap:12px;
  border-bottom:1px solid #141414;
  transition:transform .6s cubic-bezier(.22,.68,0,1.2);
  will-change:transform;
}
.banner-row.flash .br-score{animation:scoreFlash .7s ease;}
@keyframes scoreFlash{0%,100%{background:transparent;}40%{background:rgba(0,232,187,.18);border-radius:6px;}}
.br-rank{
  font-family:'Playfair Display',serif;font-size:22px;font-weight:900;
  min-width:36px;text-align:center;transition:color .4s;
}
.br-rank.r1{color:var(--gold);}
.br-rank.r2{color:#ccc;}
.br-rank.r3{color:#cd7f32;}
.br-rank.rn{color:#2a2a2a;}
.br-move{font-size:11px;min-width:18px;text-align:center;font-weight:700;}
.br-move.up{color:var(--teal);}
.br-move.dn{color:var(--red);}
.br-move.eq{color:#2a2a2a;}
.br-info{flex:1;overflow:hidden;}
.br-name{font-weight:700;font-size:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.br-sub{font-size:11px;color:var(--muted);margin-top:1px;}
.br-score{
  text-align:right;padding:4px 8px;border-radius:6px;
  transition:color .4s;min-width:60px;
}
.br-score-val{font-family:'Playfair Display',serif;font-size:22px;font-weight:900;line-height:1;}
.br-score-lbl{font-size:10px;color:var(--muted);letter-spacing:.5px;margin-top:2px;}
.br-holes{text-align:right;min-width:44px;}
.br-holes-num{font-size:12px;color:var(--muted);}
.br-holes-num.done{color:var(--gold);font-weight:700;}
.br-prog{width:36px;height:3px;background:#1e1e1e;border-radius:2px;margin:4px 0 0 auto;overflow:hidden;}
.br-prog-fill{height:100%;border-radius:2px;background:var(--teal);transition:width .6s ease;}

/* Teams banner */
.teams-banner-live{padding:14px 0;}
.tb-header{text-align:center;margin-bottom:12px;}
.tb-header-label{font-size:9px;font-weight:700;letter-spacing:2px;color:var(--muted);text-transform:uppercase;}
.tb-header-title{font-family:'Playfair Display',serif;font-size:17px;font-weight:900;margin-top:2px;}
.tb-grid{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:8px;}
.tb-team{text-align:center;padding:10px 6px;border-radius:10px;background:#0f0f0f;border:1.5px solid var(--border);transition:border-color .4s,background .4s;}
.tb-team.winning{border-color:var(--teal);background:rgba(0,232,187,.05);}
.tb-team.winning.t2{border-color:var(--red);background:rgba(255,90,90,.05);}
.tb-team-name{font-size:10px;font-weight:700;letter-spacing:1px;text-transform:uppercase;margin-bottom:4px;}
.tb-pts{font-family:'Playfair Display',serif;font-size:38px;font-weight:900;line-height:1;transition:all .4s;}
.tb-sub{font-size:11px;color:var(--muted);margin-top:4px;}
.tb-vs{font-size:12px;color:var(--muted);font-weight:700;text-align:center;}
.tb-matches{margin-top:10px;display:flex;flex-direction:column;gap:4px;max-height:110px;overflow-y:auto;}
.tb-match-row{display:flex;align-items:center;justify-content:space-between;padding:5px 8px;background:#0f0f0f;border-radius:7px;font-size:11px;gap:8px;}
.tb-match-players{color:#777;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.tb-match-result{font-weight:700;white-space:nowrap;}
.tb-match-holes{color:#ccc;font-size:10px;min-width:30px;text-align:right;}

/* â”€â”€ Selector + tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.selector-wrap{padding:14px 20px 0;max-width:960px;margin:0 auto;}
.selector-label{font-size:10px;font-weight:700;letter-spacing:1.5px;color:var(--muted);margin-bottom:7px;text-transform:uppercase;}
select.t-select{width:100%;background:var(--card);border:1.5px solid var(--border);border-radius:10px;color:var(--text);font-family:'DM Sans',sans-serif;font-size:14px;font-weight:600;padding:10px 36px 10px 13px;appearance:none;cursor:pointer;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath d='M1 1l5 5 5-5' stroke='%2300e8bb' stroke-width='1.5' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 13px center;}


/* â”€â”€ Main table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.main{max-width:960px;margin:0 auto;padding:14px 20px 48px;}
.t-title{margin-bottom:14px;}
.t-name{font-family:'Playfair Display',serif;font-size:22px;font-weight:900;letter-spacing:-.5px;line-height:1.1;}
.t-meta{font-size:12px;color:var(--muted);margin-top:4px;display:flex;gap:12px;flex-wrap:wrap;}
.lb-table{width:100%;border-collapse:collapse;font-size:14px;}
.lb-table thead th{padding:8px 11px;text-align:left;font-size:10px;font-weight:700;letter-spacing:1.5px;color:var(--muted);border-bottom:1px solid var(--border);text-transform:uppercase;}
.lb-table thead th.r{text-align:center;}
.lb-table tbody tr{border-bottom:1px solid #131313;cursor:default;}
.lb-table tbody tr.leader{background:rgba(0,232,187,.03);}
.lb-table td{padding:12px 11px;vertical-align:middle;}
.lb-table td.r{text-align:center;}
.rank-num{font-size:16px;font-weight:900;font-family:'Playfair Display',serif;}
.r1{color:var(--gold);}.r2{color:#ccc;}.r3{color:#cd7f32;}.rn{color:#2a2a2a;}
.p-name{font-weight:700;font-size:14px;}
.p-sub{font-size:11px;color:var(--muted);margin-top:2px;}
.p-team{font-size:11px;font-weight:700;margin-top:2px;}
.team-1{color:var(--teal);}.team-2{color:var(--red);}
.score-big{font-size:20px;font-weight:900;font-family:'Playfair Display',serif;text-align:center;}
.score-lbl{font-size:10px;color:var(--muted);text-align:center;margin-top:1px;letter-spacing:.5px;}
.col-teal{color:var(--teal);}.col-red{color:var(--red);}.col-grey{color:#ccc;}
.holes-wrap{text-align:center;}
.holes-num{font-size:12px;color:var(--muted);}
.holes-num.done{color:var(--gold);font-weight:700;}
.holes-bar{width:44px;height:3px;background:#1e1e1e;border-radius:2px;margin:4px auto 0;overflow:hidden;}
.holes-fill{height:100%;border-radius:2px;background:var(--teal);transition:width .5s;}
.badge{display:inline-block;padding:3px 9px;border-radius:6px;font-size:11px;font-weight:700;letter-spacing:.5px;}
.badge-live{background:rgba(0,232,187,.1);color:var(--teal);border:1px solid rgba(0,232,187,.25);}
.badge-finished{background:rgba(226,184,74,.1);color:var(--gold);border:1px solid rgba(226,184,74,.25);}

.lb-table thead th.sortable{cursor:pointer;user-select:none;white-space:nowrap;}
.lb-table thead th.sortable:hover{color:var(--text);}
.lb-table thead th.sortable.sort-active{color:var(--teal);}
.th-sort-arrow{display:inline-block;font-size:9px;margin-left:3px;opacity:.2;vertical-align:middle;transition:opacity .2s,color .2s;}
.lb-table thead th.sort-active .th-sort-arrow{opacity:1;color:var(--teal);}

/* â”€â”€ Individual matchplay match cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.ind-match-list{display:flex;flex-direction:column;gap:8px;}
.ind-match-card{border-radius:12px;overflow:hidden;background:#0f0f0f;border:1px solid var(--border);position:relative;}
.ind-match-card.imc-p1{border-left:4px solid var(--teal);}
.ind-match-card.imc-p2{border-left:4px solid var(--red);}
.ind-match-card.imc-as{border-left:4px solid #2a2a2a;}
.ind-match-card.imc-done{border-left:4px solid var(--gold);opacity:.88;}
.ind-match-body{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;padding:14px 16px;gap:10px;}
.ind-player{display:flex;flex-direction:column;gap:2px;}
.ind-player.p2-side{text-align:right;align-items:flex-end;}
.ind-player-name{font-weight:700;font-size:15px;line-height:1.2;}
.ind-player-sub{font-size:10px;color:#ccc;font-weight:600;}
/* p1 always teal, p2 always red â€” regardless of who leads */
.ind-player.p1-side .ind-player-name{color:var(--teal);}
.ind-player.p2-side .ind-player-name{color:var(--red);}
.ind-match-centre{display:flex;flex-direction:column;align-items:center;gap:5px;min-width:84px;}
.ind-result-badge{font-family:'Playfair Display',serif;font-size:17px;font-weight:900;padding:5px 14px;border-radius:20px;white-space:nowrap;line-height:1.2;text-align:center;}
.ind-match-footer{height:3px;background:#161616;overflow:hidden;}
.ind-match-prog{height:100%;border-radius:0;transition:width .6s ease;}
.imc-p1 .ind-match-prog{background:var(--teal);}
.imc-p2 .ind-match-prog{background:var(--red);}
.imc-as .ind-match-prog{background:#333;}
.imc-done .ind-match-prog{background:var(--gold);}
/* Hole detail */
.hole-detail{display:none;padding:10px 12px;background:#0d0d0d;border-top:1px solid var(--border);}
.hole-detail.open{display:block;}
.hole-pips{display:flex;flex-wrap:wrap;gap:3px;}
.pip{width:27px;height:27px;border-radius:5px;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:700;background:#161616;color:#3a3a3a;position:relative;}
.pip.scored{background:#102018;color:var(--teal);}
.pip.next{border:1.5px solid rgba(0,232,187,.35);}
.pip-n{position:absolute;top:2px;left:3px;font-size:6px;color:#2a2a2a;font-weight:600;}

/* â”€â”€ View tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.view-tabs{display:flex;gap:0;border-bottom:1px solid var(--border);background:#080808;padding:0 14px;position:sticky;top:57px;z-index:150;}
.view-tab{padding:10px 14px;font-size:12px;font-weight:700;color:#555;border:none;background:none;cursor:pointer;border-bottom:2px solid transparent;letter-spacing:.5px;white-space:nowrap;font-family:'DM Sans',sans-serif;transition:color .15s;}
.view-tab.active{color:var(--teal);border-bottom-color:var(--teal);}
.view-tab:hover:not(.active){color:#999;}
.view-panel{display:none;}.view-panel.active{display:block;}

/* â”€â”€ Match graph tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.mg-wrap{padding:14px;}
.mg-select-row{display:flex;gap:8px;margin-bottom:14px;align-items:center;flex-wrap:wrap;}
.mg-select{flex:1;min-width:200px;background:#141414;border:1.5px solid var(--border);border-radius:10px;color:#e0e0e0;font-family:'DM Sans',sans-serif;font-size:13px;padding:10px 12px;outline:none;appearance:none;-webkit-appearance:none;}
.mg-select:focus{border-color:var(--teal);}
.mg-filter-btn{padding:9px 14px;border-radius:10px;border:1.5px solid var(--border);background:transparent;color:#aaa;font-family:'DM Sans',sans-serif;font-size:11px;font-weight:700;cursor:pointer;white-space:nowrap;}
.mg-filter-btn.active{border-color:var(--teal);color:var(--teal);background:rgba(0,232,187,.08);}
.mg-card{background:var(--card);border-radius:12px;border:1px solid var(--border);overflow:hidden;margin-bottom:12px;}
.mg-card-header{padding:12px 16px;border-bottom:1px solid var(--border);}
.mg-matchlabel{font-size:9px;font-weight:700;letter-spacing:2px;color:#aaa;margin-bottom:6px;}
.mg-players{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
.mg-p1{font-size:14px;font-weight:700;color:var(--teal);}
.mg-p2{font-size:14px;font-weight:700;color:var(--red);}
.mg-vs{font-size:11px;color:#888;}
.mg-badge{padding:3px 10px;border-radius:6px;font-size:12px;font-weight:700;}
.mg-badge.live{background:rgba(0,232,187,.1);color:var(--teal);border:1px solid rgba(0,232,187,.25);}
.mg-badge.done{color:#999;border:1px solid #333;background:#1a1a1a;}
.mg-badge.t1win{background:rgba(0,232,187,.12);color:var(--teal);border:1px solid rgba(0,232,187,.3);}
.mg-badge.t2win{background:rgba(255,90,90,.12);color:var(--red);border:1px solid rgba(255,90,90,.3);}
.mg-badge.halved{background:rgba(226,184,74,.12);color:var(--gold);border:1px solid rgba(226,184,74,.3);}
.mg-graph-area{padding:12px 16px 8px;}
.mg-hole-strip{display:flex;gap:2px;padding:8px 16px 12px;flex-wrap:wrap;}
.mg-hole-dot{width:26px;height:26px;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:9px;font-weight:700;color:#000;border:1px solid transparent;}
.mg-legend{display:flex;gap:12px;padding:0 16px 12px;font-size:10px;color:#aaa;}
.mg-leg-dot{width:10px;height:10px;border-radius:2px;display:inline-block;margin-right:4px;}
.mg-empty{text-align:center;padding:48px 20px;color:#aaa;}
.mg-empty .icon{font-size:32px;margin-bottom:8px;}

/* Results */
.standings-card{background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden;margin-bottom:14px;}
.standings-header{background:linear-gradient(135deg,rgba(226,184,74,.1),rgba(0,232,187,.05));border-bottom:1px solid var(--border);padding:13px 16px;text-align:center;}
.standings-header h2{font-family:'Playfair Display',serif;font-size:17px;font-weight:900;color:var(--gold);}
.standings-header p{font-size:11px;color:var(--muted);margin-top:3px;letter-spacing:.5px;}
.standings-row{display:flex;align-items:center;padding:11px 16px;border-bottom:1px solid #181818;gap:12px;}
.standings-row:last-child{border-bottom:none;}
.standings-rank{font-size:19px;min-width:26px;font-family:'Playfair Display',serif;font-weight:900;}
.standings-info{flex:1;}
.standings-name{font-weight:700;font-size:14px;}
.standings-sub{font-size:11px;color:var(--muted);margin-top:2px;}
.standings-score{text-align:right;}
.standings-pts{font-size:21px;font-weight:900;font-family:'Playfair Display',serif;}
.standings-pts-lbl{font-size:10px;color:var(--muted);letter-spacing:.5px;}
.teams-scoreboard{background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden;margin-bottom:14px;}
.teams-result-banner{background:linear-gradient(135deg,rgba(226,184,74,.1),rgba(0,232,187,.04));border-bottom:1px solid var(--border);padding:14px;text-align:center;}
.teams-winner-lbl{font-family:'Playfair Display',serif;font-size:21px;font-weight:900;color:var(--gold);}
.tr-grid{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;padding:14px;gap:8px;}
.tr-team{text-align:center;}
.tr-team-name{font-size:11px;font-weight:700;letter-spacing:.5px;margin-bottom:3px;}
.tr-pts{font-family:'Playfair Display',serif;font-size:34px;font-weight:900;}
.tr-sub{font-size:11px;color:var(--muted);margin-top:4px;}
.tr-vs{font-size:12px;color:var(--muted);font-weight:700;}
.match-log-title{font-size:10px;font-weight:700;letter-spacing:1.5px;color:var(--muted);padding:9px 16px 5px;border-top:1px solid var(--border);text-transform:uppercase;}
.match-log-row{display:flex;justify-content:space-between;align-items:flex-start;padding:9px 16px;border-bottom:1px solid #181818;gap:10px;}
.match-log-row:last-child{border-bottom:none;}
.match-date{font-size:11px;color:var(--muted);min-width:54px;}
.match-players{font-size:12px;color:#ccc;flex:1;}
.match-result{font-size:12px;font-weight:700;text-align:right;white-space:nowrap;}
.res-t1{color:var(--teal);}.res-t2{color:var(--red);}.res-halved{color:var(--gold);}

/* State */
.state-msg{text-align:center;padding:50px 20px;color:var(--muted);}
.state-msg .icon{font-size:40px;margin-bottom:10px;}
.state-msg h3{font-size:16px;font-weight:700;color:#ccc;margin-bottom:5px;}
.state-msg p{font-size:13px;line-height:1.6;}
.last-updated{text-align:center;font-size:11px;color:#252525;margin-top:18px;letter-spacing:.5px;}

@media(max-width:600px){
  .header,.selector-wrap,.main,.banner-inner{padding-left:14px;padding-right:14px;}
  .t-name{font-size:18px;} .tb-pts{font-size:30px;}
  .br-rank{font-size:18px;} .br-score-val{font-size:18px;} .br-name{font-size:14px;}
}

/* â”€â”€ Teams Ryder Cup style â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.teams-header{background:#0d0d0d;border:1px solid var(--border);border-radius:14px;padding:0;overflow:hidden;margin-bottom:20px;}
.teams-scoreline{display:grid;grid-template-columns:1fr auto 1fr;align-items:stretch;min-height:90px;}
.team-block{display:flex;flex-direction:column;justify-content:center;align-items:center;padding:18px 12px;gap:4px;}
.team-block.t1{border-right:1px solid var(--border);}
.team-block.t2{border-left:1px solid var(--border);}
.team-block.leading-t1{background:rgba(0,232,187,.06);}
.team-block.leading-t2{background:rgba(255,90,90,.06);}
.team-lbl{font-size:9px;font-weight:700;letter-spacing:2px;text-transform:uppercase;margin-bottom:2px;}
.team-pts{font-family:'Playfair Display',serif;font-size:48px;font-weight:900;line-height:1;}
.team-record{font-size:11px;color:#ccc;margin-top:2px;}
.score-divider{display:flex;align-items:center;justify-content:center;padding:0 16px;font-size:11px;color:#777;font-weight:700;letter-spacing:1px;}
.teams-meta{border-top:1px solid var(--border);padding:8px 16px;display:flex;gap:14px;font-size:11px;color:#ccc;}
.teams-meta span{display:flex;align-items:center;gap:4px;}

/* Match cards */
.match-list{display:flex;flex-direction:column;gap:8px;margin-top:4px;}
.match-card{border-radius:12px;overflow:hidden;background:#0f0f0f;border:1px solid var(--border);position:relative;transition:border-color .3s;}
.match-card.mc-t1{border-left:4px solid var(--teal);}
.match-card.mc-t2{border-left:4px solid var(--red);}
.match-card.mc-as{border-left:4px solid #2a2a2a;}
.match-card.mc-done{border-left:4px solid var(--gold);opacity:.85;}
.match-body{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;padding:14px 16px;gap:10px;}
.match-t1-names,.match-t2-names{display:flex;flex-direction:column;gap:3px;}
.match-t2-names{text-align:right;align-items:flex-end;}
.match-player{font-weight:700;font-size:14px;line-height:1.2;}
.match-t1-names .match-player{color:var(--teal);}
.match-t2-names .match-player{color:var(--red);}
.match-centre{display:flex;flex-direction:column;align-items:center;gap:6px;min-width:80px;}
.match-result-badge{
  font-family:'Playfair Display',serif;font-size:17px;font-weight:900;
  padding:5px 14px;border-radius:20px;white-space:nowrap;line-height:1.2;
  text-align:center;
}
.mrbg-t1{background:rgba(0,232,187,.12);color:var(--teal);border:1px solid rgba(0,232,187,.3);}
.mrbg-t2{background:rgba(255,90,90,.12);color:var(--red);border:1px solid rgba(255,90,90,.3);}
.mrbg-as{background:#1a1a1a;color:#ccc;border:1px solid #2a2a2a;}
.mrbg-done{background:rgba(226,184,74,.1);color:var(--gold);border:1px solid rgba(226,184,74,.3);}
.match-thru{font-size:10px;font-weight:700;letter-spacing:.5px;}
.match-footer{height:3px;background:#161616;overflow:hidden;}
.match-progress{height:100%;border-radius:0;transition:width .6s ease;}
.mc-t1 .match-progress{background:var(--teal);}
.mc-t2 .match-progress{background:var(--red);}
.mc-as .match-progress{background:#333;}
.mc-done .match-progress{background:var(--gold);}
.match-num{font-size:10px;font-weight:700;letter-spacing:1px;color:#777;text-transform:uppercase;}
.match-leading{font-size:10px;font-weight:700;letter-spacing:.3px;}
@media(max-width:480px){
  .match-player{font-size:13px;}
  .match-result-badge{font-size:15px;padding:4px 10px;}
  .team-pts{font-size:38px;}
}


/* â”€â”€ Filter bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#filter-bar{
  max-width:960px;margin:0 auto;padding:10px 20px 0;
  display:none; /* hidden until tournament selected */
}
.filter-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.filter-search-wrap{
  flex:1;min-width:160px;position:relative;
}
.filter-search{
  width:100%;background:#0f0f0f;border:1.5px solid #1e1e1e;border-radius:10px;
  color:var(--text);font-family:'DM Sans',sans-serif;font-size:14px;
  padding:9px 36px 9px 13px;outline:none;transition:border-color .2s;
  -webkit-appearance:none;
}
.filter-search::placeholder{color:#777;}
.filter-search:focus{border-color:var(--teal);}
.filter-search-clear{
  position:absolute;right:10px;top:50%;transform:translateY(-50%);
  background:none;border:none;color:#777;font-size:16px;cursor:pointer;
  padding:4px;display:none;line-height:1;
}
.filter-search-clear.visible{display:block;color:#ccc;}

.filter-results-bar{
  margin-top:8px;font-size:11px;color:#777;font-weight:600;letter-spacing:.3px;
  min-height:18px;
}
.filter-results-bar .highlight{color:var(--teal);}
@media(max-width:600px){
  #filter-bar{padding-left:14px;padding-right:14px;}
  .filter-search{font-size:14px;}
}
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <div class="header-left">
    <button class="back-btn" id="back-btn" onclick="goBack()">â† Home</button>
    <div class="header-brand">Hill<span>fred</span></div>
  </div>
  <div style="display:flex;align-items:center;gap:8px">
    <div style="display:flex;align-items:center;gap:5px">
      <button class="refresh-btn" id="refresh-btn" onclick="manualRefresh()">â†»</button>
      <span id="refresh-countdown" style="font-size:10px;font-weight:700;color:#aaa;letter-spacing:.5px;min-width:28px;text-align:right"></span>
    </div>
    <div class="live-badge">
      <div class="live-dot" id="live-dot"></div>
      <span id="live-lbl">CONNECTING</span>
    </div>
  </div>
</div>

<!-- Offline bar -->
<div class="offline-bar" id="offline-bar">
  <span class="offline-msg">âš¡ No connection â€” data may be stale</span>
  <button class="reconnect-btn" onclick="manualRefresh()">â†» Reconnect</button>
</div>

<!-- Live Banner -->
<div id="live-banner" style="height:0;overflow:hidden;">
  <div class="banner-inner" id="banner-content"></div>
</div>

<!-- Match progress bar -->
<div class="match-progress-bar" id="match-progress-bar">
  <div class="mp-row">
    <span class="mp-label">Tournament Progress</span>
    <span class="mp-count" id="mp-count-lbl" style="color:var(--teal)">0 / 0</span>
  </div>
  <div class="mp-track"><div class="mp-fill" id="mp-fill" style="width:0%"></div></div>
</div>

<!-- Selector -->
<div class="selector-wrap">
  <div class="selector-label">Tournament</div>
  <select class="t-select" id="t-select" onchange="onTournamentChange(this.value)">
    <option value="">â€” Select tournament â€”</option>
  </select>

</div>

<!-- View tabs -->
<div class="view-tabs" id="view-tabs">
  <button class="view-tab active" onclick="switchTab('leaderboard')">ğŸ“Š Leaderboard</button>
  <button class="view-tab" onclick="switchTab('graphs')">ğŸ“ˆ Match Graphs</button>
</div>

<!-- Filter bar -->
<div id="filter-bar">
  <div class="filter-row">
    <div class="filter-search-wrap">
      <input class="filter-search" id="filter-search" type="text" placeholder="Search playerâ€¦" oninput="onFilterInput(this.value)"/>
      <button class="filter-search-clear" id="filter-search-clear" onclick="clearSearch()">âœ•</button>
    </div>
  </div>

  <div class="filter-results-bar" id="filter-results-bar"></div>
</div>

<!-- SGG Combined Scoreboard (shown when SGG tournament selected) -->
<div id="sgg-banner" style="display:none;padding:0 14px 4px"></div>

<!-- Leaderboard panel -->
<div class="view-panel active" id="panel-leaderboard">
  <div class="main" id="main-content">
    <div class="state-msg">
      <div class="icon">ğŸŒï¸</div>
      <h3>Live Leaderboard</h3>
      <p>Select a tournament above to see live scores and final results.</p>
    </div>
  </div>
  <div class="last-updated" id="last-updated"></div>
</div>

<!-- Match Graphs panel -->
<div class="view-panel" id="panel-graphs">
  <div class="mg-wrap">
    <div class="mg-select-row">
      <select class="mg-select" id="mg-match-select" onchange="onMatchSelect(this.value)">
        <option value="">â€” Select a match â€”</option>
      </select>
      <button class="mg-filter-btn active" id="mgf-all" onclick="setMgFilter('all')">All</button>
      <button class="mg-filter-btn" id="mgf-live" onclick="setMgFilter('live')">â— Live</button>
      <button class="mg-filter-btn" id="mgf-done" onclick="setMgFilter('finished')">âœ“ Done</button>
    </div>
    <div id="mg-content">
      <div class="mg-empty"><div class="icon">ğŸ“ˆ</div><p>Select a match above to view its worm graph</p></div>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import { getDatabase, ref, onValue, remove } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBg_tfMOtzhcpMlTl-2o_2bfs0Dos8EHPM",
  authDomain: "hillfred-golf.firebaseapp.com",
  databaseURL: "https://hillfred-golf-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "hillfred-golf",
  storageBucket: "hillfred-golf.firebasestorage.app",
  messagingSenderId: "1047089194868",
  appId: "1:1047089194868:web:3f5fab20d2bc15154f2e21"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

// â”€â”€ Multi-tenant client config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LB_CLIENT_ID = new URLSearchParams(window.location.search).get('client') || null;
if (LB_CLIENT_ID) {
  // Load client config from Firebase once connection established
  onValue(ref(db, `clients/${LB_CLIENT_ID}/config`), snap => {
    if (!snap.exists()) return;
    const config = snap.val();
    if (config.primaryColor) document.documentElement.style.setProperty('--teal', config.primaryColor);
    if (config.name) document.title = config.name + ' Â· Live Leaderboard';
    if (config.poweredBy === false) {
      const wm = document.querySelector('.hf-watermark');
      if (wm) wm.style.display = 'none';
    }
  }, { onlyOnce: true });
}

let currentKey    = '';
let liveScores    = {};
// SGG combined: also subscribe to sibling day scores
let sggSiblingScores = {};
let unsubSibling  = null;
const SGG_KEYS    = ['sgg_2026_day1','sgg_2026_day2'];
const SGG_DAY_INFO = {
  'sgg_2026_day1': { day:1, course:'Bonnie Doon',       fmt:'4BBB',   total:7  },
  'sgg_2026_day2': { day:2, course:'Stonecutters Ridge', fmt:'Singles',total:15 }
};
let unsubScores   = null;
let unsubCounts   = null;
let _gameCount    = 0;
let _completedCount = 0;

// â”€â”€ Filter / sort state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let filterSearch  = '';
let filterSort    = 'score';   // 'score' | 'holes' | 'name' | 'status'
let sortDir       = {};        // { score: 1, holes: -1, ... } â€” 1=asc, -1=desc
// Defaults: score asc (low=good), holes desc (most played first), name asc, status asc
// score dir=1: stroke â†’ lowest net-to-par first; stableford â†’ highest points first
const sortDefaults = { score:1, holes:-1, name:1, status:1 };
// Sort arrows initialised in renderLive after table is injected

// â”€â”€ Rank history for movement arrows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// playerKey -> previous rank (1-based)
const prevRanks = {};

// â”€â”€ Connection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _wasConnected = false;
onValue(ref(db, '.info/connected'), snap => {
  const on = snap.val() === true;
  document.getElementById('live-dot').className = 'live-dot' + (on ? '' : ' off');
  document.getElementById('live-lbl').textContent = on ? 'LIVE' : 'OFFLINE';
  const offlineBar = document.getElementById('offline-bar');
  if (offlineBar) offlineBar.classList.toggle('visible', !on);
  // If we reconnected after being offline, re-subscribe to refresh data
  if (on && !_wasConnected && currentKey) {
    onTournamentChange(currentKey);
  }
  _wasConnected = on;
});

// â”€â”€ Manual refresh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.manualRefresh = function() {
  const btn = document.getElementById('refresh-btn');
  if (btn) {
    btn.classList.add('spinning');
    setTimeout(() => btn.classList.remove('spinning'), 700);
  }
  _startAutoRefresh(); // reset the 30s countdown
  // Hard reload clears PWA cache and re-establishes Firebase connection
  window.location.reload(true);
};

// â”€â”€ Dropdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
onValue(ref(db, 'tournaments'), snap => {
  const data = snap.val() || {};
  const sel  = document.getElementById('t-select');
  const cur  = sel.value;
  const seen = new Set(Array.from(sel.options).map(o => o.value).filter(Boolean));
  Object.entries(data).forEach(([key, val]) => {
    if (seen.has(key)) return;
    // Skip non-tournament entries (e.g. stray 'status', 'closedAt' keys)
    if (!val || typeof val !== 'object' || (!val.scores && !val.gameCount && !val.results)) return;
    const scores = val.scores || {};
    const meta   = Object.values(scores).map(g => g && g._meta).find(Boolean) || {};
    const lbl    = (val.results && val.results.label) || meta.tournamentLabel || key;
    const opt    = document.createElement('option');
    opt.value = key; opt.textContent = lbl;
    sel.appendChild(opt);
  });
  if (cur && data[cur]) sel.value = cur;

  // Auto-select if only one tournament and none currently selected
  const realOpts = Array.from(sel.options).filter(o => o.value);
  if (!cur && realOpts.length === 1) {
    sel.value = realOpts[0].value;
    window.onTournamentChange(realOpts[0].value);
  }

  // Clean up any stray non-tournament keys written by old finalise code
  Object.entries(data).forEach(([key, val]) => {
    if (!val || typeof val !== 'object' || (!val.scores && !val.gameCount && !val.results)) {
      remove(ref(db, `tournaments/${key}`)).catch(()=>{});
    }
  });
});

// â”€â”€ Tournament change â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.onTournamentChange = function(key) {
  currentKey = key;
  if (unsubScores) { unsubScores(); unsubScores = null; }
  liveScores = {};
  Object.keys(prevRanks).forEach(k => delete prevRanks[k]);

  // back button href is set from URL ?back= param at init
  hideBanner();

  if (!key) {
    document.getElementById('main-content').innerHTML =
      `<div class="state-msg"><div class="icon">ğŸŒï¸</div><h3>Live Leaderboard</h3><p>Select a tournament above.</p></div>`;
  showFilterBar(false);
    return;
  }

  document.getElementById('main-content').innerHTML =
    `<div class="state-msg"><div class="icon">â³</div><h3>Loadingâ€¦</h3></div>`;
  // Show filter bar, reset search on new tournament
  filterSearch = '';
  sortDir = {};   // reset sort directions on each new tournament
  filterSort = 'score';
  const inp = document.getElementById('filter-search');
  if (inp) inp.value = '';
  const clr = document.getElementById('filter-search-clear');
  if (clr) clr.classList.remove('visible');
  showFilterBar(true);

  // If this is an SGG day, also subscribe to the sibling day's scores
  if (unsubSibling) { unsubSibling(); unsubSibling = null; }
  sggSiblingScores = {};
  if (SGG_KEYS.includes(key)) {
    const sibKey = key === 'sgg_2026_day1' ? 'sgg_2026_day2' : 'sgg_2026_day1';
    unsubSibling = onValue(ref(db, `tournaments/${sibKey}/scores`), snap => {
      sggSiblingScores = snap.val() || {};
      renderSGGBanner();
    });
  }

  unsubScores = onValue(ref(db, `tournaments/${key}/scores`), snap => {
    liveScores = snap.val() || {};
    render();
  });

  // Subscribe to game count trackers
  if (unsubCounts) { unsubCounts(); unsubCounts = null; }
  _gameCount = 0; _completedCount = 0;
  let _gcLoaded = false, _ccLoaded = false;
  const unsubGC = onValue(ref(db, `tournaments/${key}/gameCount`), snap => {
    _gameCount = snap.val() || 0;
    _gcLoaded = true;
    if (_gcLoaded && _ccLoaded) renderMatchProgress();
  });
  const unsubCC = onValue(ref(db, `tournaments/${key}/completedCount`), snap => {
    _completedCount = snap.val() || 0;
    _ccLoaded = true;
    if (_gcLoaded && _ccLoaded) renderMatchProgress();
  });
  unsubCounts = () => { unsubGC(); unsubCC(); };
  // Reset the auto-refresh countdown whenever a tournament is (re-)selected
  _startAutoRefresh();
};

// â”€â”€ Match progress bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderMatchProgress() {
  const bar = document.getElementById('match-progress-bar');
  if (!currentKey || _gameCount === 0) {
    if (bar) bar.classList.remove('visible');
    return;
  }
  const total     = _gameCount;
  const completed = _completedCount;
  const pct       = Math.min(100, Math.round((completed / total) * 100));
  const allDone   = completed >= total;

  if (bar) {
    bar.classList.add('visible');
    document.getElementById('mp-count-lbl').textContent = allDone ? `${completed} / ${total} â€” Complete ğŸ` : `${completed} / ${total}`;
    document.getElementById('mp-count-lbl').style.color = allDone ? 'var(--gold)' : 'var(--teal)';
    document.getElementById('mp-fill').style.width = pct + '%';
    document.getElementById('mp-fill').style.background = allDone ? 'var(--gold)' : 'var(--teal)';
  }
}


// â”€â”€ Filter & sort helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.onFilterInput = function(val) {
  filterSearch = val.trim().toLowerCase();
  const clr = document.getElementById('filter-search-clear');
  if (clr) clr.classList.toggle('visible', filterSearch.length > 0);
  render();
};

window.clearSearch = function() {
  filterSearch = '';
  const inp = document.getElementById('filter-search');
  if (inp) inp.value = '';
  const clr = document.getElementById('filter-search-clear');
  if (clr) clr.classList.remove('visible');
  render();
};

window.setSort = function(key) {
  if (filterSort === key) {
    // Toggle direction on second tap
    sortDir[key] = (sortDir[key] || sortDefaults[key]) * -1;
  } else {
    filterSort = key;
    if (sortDir[key] == null) sortDir[key] = sortDefaults[key];
  }
  // Update column header active state + arrows
  ['score','holes','name','status'].forEach(k => {
    const thEl  = document.getElementById('th-' + k);
    const arrEl = document.getElementById('arr-' + k);
    const isActive = k === filterSort;
    if (thEl)  thEl.classList.toggle('sort-active', isActive);
    if (arrEl) {
      if (isActive) {
        arrEl.textContent = (sortDir[k] ?? sortDefaults[k]) === 1 ? 'â†‘' : 'â†“';
        arrEl.style.opacity = '1';
      } else {
        arrEl.textContent = 'â†•';
        arrEl.style.opacity = '0.2';
      }
    }
  });
  render();
};

function applyFilterSort(entries) {
  // 1. Search filter
  let out = filterSearch
    ? entries.filter(e => e.name.toLowerCase().includes(filterSearch))
    : entries;

  // 2. Sort
  const dir = sortDir[filterSort] ?? sortDefaults[filterSort];
  out = [...out].sort((a, b) => {
    switch (filterSort) {
      case 'score': {
        if (a.mode === 'stableford') {
          // Stableford: higher = better. Default dir=1 â†’ highest first (best first).
          const aZero = a.stabTotal === 0 && a.holesPlayed === 0;
          const bZero = b.stabTotal === 0 && b.holesPlayed === 0;
          if (aZero && !bZero) return 1;
          if (bZero && !aZero) return -1;
          // dir=1 â†’ highest first (b-a); dir=-1 â†’ lowest first (a-b)
          return dir * (b.stabTotal - a.stabTotal);
        }
        if (a.mode === 'matchplay') {
          if (a.holesPlayed !== b.holesPlayed) return b.holesPlayed - a.holesPlayed;
          return dir * ((a.mpLeading||0) - (b.mpLeading||0));
        }
        // Stroke: lower net-to-par = better. Default dir=1 â†’ lowest first (a-b).
        const aUnstarted = a.holesPlayed === 0;
        const bUnstarted = b.holesPlayed === 0;
        if (aUnstarted && !bUnstarted) return 1;
        if (bUnstarted && !aUnstarted) return -1;
        // dir=1 â†’ lowest diff first (a-b); dir=-1 â†’ highest first (b-a)
        return dir * ((a.netTotal - a.par) - (b.netTotal - b.par));
      }
      case 'holes':
        return dir * (a.holesPlayed - b.holesPlayed);
      case 'name':
        return dir * a.name.localeCompare(b.name);
      case 'status': {
        // Finished > Active > Not started
        const statusOrder = { finished:0, active:1 };
        const sa = statusOrder[a.status] ?? 2;
        const sb = statusOrder[b.status] ?? 2;
        return dir * (sa - sb);
      }
    }
    return 0;
  });

  return out;
}

function updateFilterResultsBar(total, filtered) {
  const bar = document.getElementById('filter-results-bar');
  if (!bar) return;
  if (!filterSearch) {
    bar.innerHTML = '';
    return;
  }
  if (filtered === 0) {
    bar.innerHTML = `No players match <span class="highlight">"${filterSearch}"</span>`;
  } else {
    bar.innerHTML = `Showing <span class="highlight">${filtered}</span> of ${total} player${total!==1?'s':''}`;
  }
}

function showFilterBar(visible) {
  const fb = document.getElementById('filter-bar');
  if (fb) fb.style.display = visible ? 'block' : 'none';
}

// â”€â”€ Master render â€” always shows live scores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ SGG International 2026 Combined Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSGGBanner() {
  const el = document.getElementById('sgg-banner');
  if (!el) return;
  if (!SGG_KEYS.includes(currentKey)) { el.style.display='none'; return; }

  // Format points: whole numbers show as integer, halves show as X.5
  const pts = v => Number.isInteger(v) ? String(v) : v.toFixed(1);

  // Tally finished games from this day's scores
  const tallyScores = (scores) => {
    let row=0, aus=0, played=0;
    if (!scores) return {row,aus,played};
    Object.values(scores).forEach(gd => {
      if (!gd || !gd._meta) return;
      if (gd._meta.status !== 'finished') return;
      const players = Object.entries(gd).filter(([k])=>k!=='_meta');
      if (!players.length) return;

      // Collect mpStatus and mpLeading from the last hole of every player
      // Use ALL players to avoid relying on any single one
      let leading = 0;
      let allStatuses = [];
      players.forEach(([,pd]) => {
        const hp = pd.holesPlayed || 0;
        if (hp > 0) {
          const last = pd[`h${hp}`] || {};
          allStatuses.push(last.mpStatus || '');
          // Only take mpLeading from a player where it's non-zero (a decisive result)
          if ((last.mpLeading||0) !== 0 && leading === 0) leading = last.mpLeading;
        }
      });

      const anyStatus = allStatuses.join(' ');
      // A match is halved if ANY player's status says All Square or Halved
      // AND no player has a non-zero mpLeading (which would indicate a winner)
      const halved = (anyStatus.includes('All Square') || anyStatus.includes('Halved')) && leading === 0;

      if      (halved)      { row += 0.5; aus += 0.5; played++; }
      else if (leading===1) { row += 1;                played++; }
      else if (leading===2) { aus += 1;                played++; }
      else if (players.some(([,pd])=>(pd.holesPlayed||0)>0)) played++;
    });
    return {row,aus,played};
  };

  const isCurrDay1 = currentKey === 'sgg_2026_day1';
  const currInfo  = SGG_DAY_INFO[currentKey];
  const sibInfo   = SGG_DAY_INFO[isCurrDay1 ? 'sgg_2026_day2' : 'sgg_2026_day1'];

  const currT = tallyScores(liveScores);
  const sibT  = tallyScores(sggSiblingScores);

  const d1t = isCurrDay1 ? currT : sibT;
  const d2t = isCurrDay1 ? sibT  : currT;

  const rowTotal = d1t.row + d2t.row;
  const ausTotal = d1t.aus + d2t.aus;
  const totalPlayed = d1t.played + d2t.played;
  const totalMatches = 22;

  const rowPct = Math.round((rowTotal/totalMatches)*100);
  const ausPct = Math.round((ausTotal/totalMatches)*100);

  // Status message
  let statusHtml = '';
  const pToWin=11.5, pToRetain=11;
  if (rowTotal>=pToWin) {
    statusHtml=`<div style="text-align:center;padding:10px;background:rgba(0,232,187,.1);border-top:1px solid rgba(0,232,187,.15);border-radius:0 0 14px 14px;font-weight:800;color:var(--teal);font-size:13px;letter-spacing:.5px">ğŸ† ROW WIN THE SGG INTERNATIONAL!</div>`;
  } else if (ausTotal>=pToWin) {
    statusHtml=`<div style="text-align:center;padding:10px;background:rgba(255,90,90,.1);border-top:1px solid rgba(255,90,90,.15);border-radius:0 0 14px 14px;font-weight:800;color:var(--red);font-size:13px;letter-spacing:.5px">ğŸ† AUS WIN THE SGG INTERNATIONAL!</div>`;
  } else if (ausTotal>=pToRetain && totalPlayed>=totalMatches) {
    statusHtml=`<div style="text-align:center;padding:10px;background:rgba(226,184,74,.1);border-top:1px solid rgba(226,184,74,.15);border-radius:0 0 14px 14px;font-weight:800;color:var(--gold);font-size:13px;letter-spacing:.5px">ğŸ† AUS RETAIN THE SGG INTERNATIONAL!</div>`;
  } else {
    const rowNeeds=Math.max(0,pToWin-rowTotal).toFixed(1).replace('.0','');
    const ausNeeds=Math.max(0,pToRetain-ausTotal).toFixed(1).replace('.0','');
    statusHtml=`<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;padding:8px 12px 10px;border-top:1px solid #111">
      <div style="text-align:center;font-size:10px;color:#ccc">ROW need <span style="color:var(--teal);font-weight:700">${rowNeeds}</span> to win</div>
      <div style="text-align:center;font-size:10px;color:#ccc">AUS need <span style="color:var(--red);font-weight:700">${ausNeeds}</span> to retain</div>
    </div>`;
  }

  el.style.display = 'block';
  el.innerHTML = `<div style="background:linear-gradient(135deg,#0a0a0a,#111);border:1.5px solid #1e1e1e;border-radius:16px;overflow:hidden;margin-bottom:4px">
    <div style="padding:14px 14px 10px">
      <div style="font-size:9px;font-weight:800;letter-spacing:2.5px;color:#ccc;margin-bottom:10px">â›³ SGG INTERNATIONAL 2026 Â· COMBINED</div>
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
        <div style="text-align:center">
          <div style="font-size:9px;font-weight:700;letter-spacing:1px;color:var(--teal);margin-bottom:2px">ROW</div>
          <div style="font-size:40px;font-weight:900;color:var(--teal);line-height:1">${pts(rowTotal)}</div>
        </div>
        <div style="flex:1">
          <div style="height:8px;background:#1a1a1a;border-radius:4px;overflow:hidden;display:flex;margin-bottom:5px">
            <div style="width:${rowPct}%;background:var(--teal);transition:width .6s;border-radius:4px 0 0 4px;flex-shrink:0"></div>
            <div style="width:${ausPct}%;background:var(--red);transition:width .6s;border-radius:0 4px 4px 0;flex-shrink:0;margin-left:auto"></div>
          </div>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px">
            <div style="background:#0d0d0d;border-radius:8px;padding:6px 8px;font-size:9px">
              <div style="color:#ccc;font-weight:700;letter-spacing:1px;margin-bottom:3px">D1 Â· 4BBB</div>
              <div style="display:flex;justify-content:space-between">
                <span style="color:var(--teal);font-weight:800">${pts(d1t.row)}</span>
                <span style="color:#777;font-size:9px">${d1t.played}/7</span>
                <span style="color:var(--red);font-weight:800">${pts(d1t.aus)}</span>
              </div>
            </div>
            <div style="background:#0d0d0d;border-radius:8px;padding:6px 8px;font-size:9px">
              <div style="color:#ccc;font-weight:700;letter-spacing:1px;margin-bottom:3px">D2 Â· SINGLES</div>
              <div style="display:flex;justify-content:space-between">
                <span style="color:var(--teal);font-weight:800">${pts(d2t.row)}</span>
                <span style="color:#777;font-size:9px">${d2t.played}/15</span>
                <span style="color:var(--red);font-weight:800">${pts(d2t.aus)}</span>
              </div>
            </div>
          </div>
        </div>
        <div style="text-align:center">
          <div style="font-size:9px;font-weight:700;letter-spacing:1px;color:var(--red);margin-bottom:2px">AUS ğŸ†</div>
          <div style="font-size:40px;font-weight:900;color:var(--red);line-height:1">${pts(ausTotal)}</div>
        </div>
      </div>
    </div>
    ${statusHtml}
  </div>`;
}


function render() {
  renderSGGBanner();
  renderLive('all');
  const ts = new Date().toLocaleTimeString('en-AU',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
  document.getElementById('last-updated').textContent = `Updated ${ts}`;
}

// â”€â”€ Parse live score entries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parseEntries(modeFilter) {
  const entries = [];
  Object.entries(liveScores).forEach(([gameId, gd]) => {
    if (!gd) return;
    const meta = gd._meta || {};
    Object.entries(gd).forEach(([pKey, pData]) => {
      if (pKey === '_meta' || !pData) return;
      if (modeFilter !== 'all' && meta.mode !== modeFilter) return;
      const hp   = pData.holesPlayed || 0;
      const last = hp > 0 ? (pData[`h${hp}`] || {}) : {};
      entries.push({
        gameId, key: pKey,
        name: pKey.replace(/_/g,' '),
        holesPlayed: hp,
        grossTotal: last.grossTotal||0,
        netTotal:   last.netTotal||0,
        stabTotal:  last.stabTotal||0,
        par:        last.par||0,
        mode: meta.mode||last.mode||(meta.team?'matchplay':'stroke'),
        team: meta.team||last.team||false,
        teamName: last.teamName||null,
        mpStatus:  last.mpStatus||null,
        mpLeading: last.mpLeading||0,
        matchIndex: pData.matchIndex||1,            // 1=Match1 (p1/p2), 2=Match2 (p3/p4)
        status: meta.status||'active',
        course: meta.course||'â€”',
        tLabel: meta.tournamentLabel||currentKey,
        t1name: meta.team1name||last.t1name||'Team 1',
        t2name: meta.team2name||last.t2name||'Team 2',
        holeData: pData,
      });
    });
  });
  entries.sort((a,b) => {
    if (a.mode === 'stableford') {
      if (a.holesPlayed === 0 && b.holesPlayed > 0) return 1;
      if (b.holesPlayed === 0 && a.holesPlayed > 0) return -1;
      return b.stabTotal - a.stabTotal;
    }
    // Push unstarted players to the bottom
    if (a.holesPlayed === 0 && b.holesPlayed > 0) return 1;
    if (b.holesPlayed === 0 && a.holesPlayed > 0) return -1;
    return (a.netTotal - a.par) - (b.netTotal - b.par);
  });
  return entries;
}

// â”€â”€ Detect if scores are team play â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function detectTeamPlay(entries) {
  // Check any entry â€” don't rely solely on first entry which may have team:false
  return entries.some(e => e.team === true);
}

// â”€â”€ Compute live team scores from entries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function computeTeamScores(entries) {
  // Read team names from the first entry that has them â€” fallback gracefully
  const _t1 = entries.find(e => e.t1name)?.t1name || 'Team 1';
  const _t2 = entries.find(e => e.t2name)?.t2name || 'Team 2';
  const t1name  = _t1;
  const t2name  = _t2;
  const mode    = entries[0]?.mode   || 'stroke';
  const isStab  = mode === 'stableford';
  const isMatch = mode === 'matchplay';

  // Group by gameId â€” each game = one match row
  // Use each entry's own teamName to bucket into t1/t2 â€” never rely on global t1name alone
  const games = {};
  entries.forEach(e => {
    if (!games[e.gameId]) {
      // Snapshot the team names from this game's first entry
      games[e.gameId] = { t1:[], t2:[], status:'active', hp:0,
        t1name: e.t1name || t1name, t2name: e.t2name || t2name };
    }
    const g = games[e.gameId];
    // Match by teamName string â€” if teamName is missing fall back to position order
    if (!e.teamName) {
      // No teamName stored â€” use insertion order (first 2 = t1, next 2 = t2)
      if (g.t1.length <= g.t2.length) g.t1.push(e);
      else g.t2.push(e);
    } else if (e.teamName === g.t1name) {
      g.t1.push(e);
    } else {
      g.t2.push(e);
    }
    g.hp = Math.max(g.hp, e.holesPlayed);
    if (e.status === 'finished') g.status = 'finished';
  });

  let t1pts = 0, t2pts = 0, halved = 0;
  const matchRows = [];
  let matchNum = 1;

  Object.values(games).forEach(g => {
    if (!g.t1.length || !g.t2.length) return;

    // â”€â”€ Determine result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let res, resCls, resultLabel;
    if (isMatch) {
      // mpLeading: 1 = Team1 (p1-side) leads, 2 = Team2 (p2-side) leads, 0 = AS
      // mpStatus: the label string e.g. "2 UP", "3&2", "All Square"
      // Use mpLeading from any player â€” it's the same for all players in a game
      const anyEntry   = [...g.t1, ...g.t2].find(p => p.mpStatus && p.mpStatus !== 'â€”');
      const rawLabel   = anyEntry?.mpStatus || 'AS';
      const leading    = anyEntry?.mpLeading ?? 0;  // 0=AS, 1=Team1, 2=Team2

      const done = g.status === 'finished';
      // Strip W /L prefix â€” colour coding already conveys winner
      const cleanLabel = rawLabel.replace(/^[WL] /, '');
      if (leading === 1) {
        res = 1; resCls = 't1';
        if (done) t1pts++;
        resultLabel = cleanLabel;
      } else if (leading === 2) {
        res = 2; resCls = 't2';
        if (done) t2pts++;
        resultLabel = cleanLabel;
      } else if (rawLabel.includes('&')) {
        const t1win = g.t1.find(p => (p.mpLeading === 1));
        const t2win = g.t2.find(p => (p.mpLeading === 2));
        if (t1win)      { res = 1; resCls = 't1'; if (done) t1pts++; }
        else if (t2win) { res = 2; resCls = 't2'; if (done) t2pts++; }
        else            { res = 0; resCls = 'as';  if (done) halved++; }
        resultLabel = cleanLabel;
      } else {
        res = 0; resCls = 'as';
        if (done) halved++;
        resultLabel = cleanLabel === 'All Square' || !cleanLabel ? 'AS' : cleanLabel;
      }
    } else if (isStab) {
      const s1 = Math.max(...g.t1.map(p=>p.stabTotal));
      const s2 = Math.max(...g.t2.map(p=>p.stabTotal));
      const done = g.status === 'finished';
      if (s1 > s2)      { res=1; resCls='t1'; if(done) t1pts++; resultLabel=`${s1} pts`; }
      else if (s2 > s1) { res=2; resCls='t2'; if(done) t2pts++; resultLabel=`${s2} pts`; }
      else              { res=0; resCls='as';  if(done) halved++;  resultLabel='AS'; }
    } else {
      const s1 = Math.min(...g.t1.map(p=>p.netTotal));
      const s2 = Math.min(...g.t2.map(p=>p.netTotal));
      const done = g.status === 'finished';
      if (s1 < s2)      { res=1; resCls='t1'; if(done) t1pts++; resultLabel=`Net ${s1}`; }
      else if (s2 < s1) { res=2; resCls='t2'; if(done) t2pts++; resultLabel=`Net ${s2}`; }
      else              { res=0; resCls='as';  if(done) halved++;  resultLabel='AS'; }
    }

    matchRows.push({
      matchNum: matchNum++,
      t1players: g.t1.map(p => p.name),
      t2players: g.t2.map(p => p.name),
      resultLabel, res, resCls,
      hp: g.hp,
      status: g.status,
      isPairs: g.t1.length > 1 || g.t2.length > 1,
    });
  });

  // Sort: live matches first (most holes played â†’ top), finished last
  matchRows.sort((a, b) => {
    const aLive = a.status !== 'finished';
    const bLive = b.status !== 'finished';
    if (aLive && !bLive) return -1;   // live before finished
    if (!aLive && bLive) return 1;
    if (aLive && bLive)  return b.hp - a.hp;  // live: most holes played first
    return b.hp - a.hp;  // finished: most holes played first (tiebreak by progress)
  });

  // Re-number after sort
  matchRows.forEach((m, i) => { m.matchNum = i + 1; });

  return { t1name, t2name, t1pts, t2pts, halved, matchRows, mode, isStab, isMatch };
}

// Format points: integer â†’ "2", half â†’ "2.5"
function fmtPts(v) { return Number.isInteger(v) ? String(v) : v.toFixed(1); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIVE BANNER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ROW_H = 72;

function hideBanner() {
  const b = document.getElementById('live-banner');
  b.style.height = '0';
  setTimeout(() => { b.style.overflow='hidden'; }, 400);
}

function showBannerIndividual(entries) {
  const banner  = document.getElementById('live-banner');
  const content = document.getElementById('banner-content');

  // Compute current ranks
  const curRanks = {};
  entries.forEach((e, i) => { curRanks[e.key] = i + 1; });

  // Build / update rows using FLIP animation
  // First render: build static HTML
  const isStab = entries[0]?.mode === 'stableford';
  const tLabel = entries[0]?.tLabel || '';
  const titleStr = `ğŸŒï¸ ${tLabel} &nbsp;Â·&nbsp; ${isStab ? 'STABLEFORD' : entries[0]?.mode === 'matchplay' ? 'MATCHPLAY' : 'STROKE PLAY'}`;

  // Build row HTML lookup
  const rowHtmlMap = {};
  entries.forEach((e, i) => {
    const rank   = i + 1;
    const rCls   = rank===1?'r1':rank===2?'r2':rank===3?'r3':'rn';
    const pRank  = prevRanks[e.key];
    let moveCls = 'eq', moveSym = 'Â·';
    if (pRank != null && pRank !== rank) {
      if (rank < pRank) { moveCls = 'up'; moveSym = 'â–²'; }
      else              { moveCls = 'dn'; moveSym = 'â–¼'; }
    }

    let scoreVal, scoreLabel, scoreCol;
    if (e.mode === 'stableford') {
      scoreVal = e.stabTotal; scoreLabel = 'PTS'; scoreCol = 'col-teal';
    } else if (e.mode === 'matchplay') {
      // Strip W /L prefix â€” colour already conveys win/loss
      const cleanStatus = (e.mpStatus || '').replace(/^[WL] /, '');
      scoreVal = cleanStatus || (e.holesPlayed===0?'AS':'â€”');
      scoreLabel = 'MATCH';
      scoreCol = !e.mpStatus ? 'col-grey'
        : e.mpStatus.includes('DOWN') || e.mpStatus.startsWith('L ') ? 'col-red'
        : e.mpStatus.includes('UP')   || e.mpStatus.startsWith('W ') ? 'col-teal'
        : 'col-grey';
    } else {
      const diff = e.netTotal - e.par;
      scoreVal  = diff === 0 ? 'E' : (diff > 0 ? '+' : '') + diff;
      scoreLabel = `NET ${e.netTotal}`;
      scoreCol  = diff < 0 ? 'col-teal' : diff > 0 ? 'col-red' : 'col-grey';
    }

    const tCls    = e.teamName===e.t1name?'team-1':e.teamName===e.t2name?'team-2':'';
    const pct     = Math.round((e.holesPlayed/18)*100);
    const doneCls = e.holesPlayed===18?'done':'';

    rowHtmlMap[e.key] = `
      <span class="br-rank ${rCls}">${rank}</span>
      <span class="br-move ${moveCls}">${moveSym}</span>
      <span class="br-info">
        <span class="br-name">${e.name}</span>
        <span class="br-sub">${e.teamName?`<span class="${tCls}">${e.teamName}</span> Â· `:''} ${e.course} Â· ${e.holesPlayed}/18</span>
      </span>
      <span class="br-score ${scoreCol}">
        <span class="br-score-val">${scoreVal}</span>
        <span class="br-score-lbl">${scoreLabel}</span>
      </span>
      <span class="br-holes">
        <span class="br-holes-num ${doneCls}">${e.holesPlayed}/18</span>
        <span class="br-prog"><span class="br-prog-fill" style="width:${pct}%"></span></span>
      </span>`;
  });

  // Check if rail already exists
  let rail = content.querySelector('.banner-rail');
  const totalH = entries.length * ROW_H;

  if (!rail) {
    // First render â€” build from scratch
    content.innerHTML = `
      <div class="banner-title">${titleStr}</div>
      <div class="banner-rail" style="height:${totalH}px"></div>`;
    rail = content.querySelector('.banner-rail');

    entries.forEach((e, i) => {
      const row = document.createElement('div');
      row.className = 'banner-row';
      row.id = 'brow-' + e.key;
      row.style.transform = `translateY(${i * ROW_H}px)`;
      row.innerHTML = rowHtmlMap[e.key];
      rail.appendChild(row);
    });

  } else {
    // Update: FLIP animate existing rows into new positions
    // Record "Before" positions
    const beforeY = {};
    entries.forEach(e => {
      const el = document.getElementById('brow-' + e.key);
      if (el) beforeY[e.key] = el.getBoundingClientRect().top;
    });

    // Update content
    entries.forEach((e, i) => {
      let row = document.getElementById('brow-' + e.key);
      if (!row) {
        row = document.createElement('div');
        row.className = 'banner-row';
        row.id = 'brow-' + e.key;
        rail.appendChild(row);
        beforeY[e.key] = null;
      }
      row.innerHTML = rowHtmlMap[e.key];
    });

    // Record "After" intended positions, then animate
    entries.forEach((e, i) => {
      const row = document.getElementById('brow-' + e.key);
      if (!row) return;
      const targetY = i * ROW_H;

      if (beforeY[e.key] == null) {
        // New row â€” just place it
        row.style.transition = 'none';
        row.style.transform = `translateY(${targetY}px)`;
        row.classList.add('flash');
        setTimeout(() => row.classList.remove('flash'), 800);
      } else {
        // Animate to new position
        row.style.transition = 'none';
        row.style.transform = row.style.transform; // keep current
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            row.style.transition = 'transform .65s cubic-bezier(.22,.68,0,1.2)';
            row.style.transform = `translateY(${targetY}px)`;
          });
        });
        // Flash if score changed
        const scoreChanged = prevRanks[e.key] != null && prevRanks[e.key] !== (i+1);
        if (scoreChanged) {
          row.classList.add('flash');
          setTimeout(() => row.classList.remove('flash'), 900);
        }
      }
    });

    // Update rail height
    rail.style.height = totalH + 'px';
  }

  // Update banner height
  const titleEl = content.querySelector('.banner-title');
  const titleH  = titleEl ? titleEl.offsetHeight : 28;
  banner.style.overflow = 'visible';
  banner.style.height   = (titleH + 10 + totalH + 18) + 'px';

  // Save ranks for next update
  entries.forEach((e, i) => { prevRanks[e.key] = i + 1; });
}

function renderTeamsLive(entries, main, allEntries) {
  hideBanner();
  const ts     = computeTeamScores(entries);
  const tLabel = entries[0]?.tLabel || '';
  const t1Total = ts.t1pts + ts.halved * 0.5;
  const t2Total = ts.t2pts + ts.halved * 0.5;
  const t1Lead = t1Total > t2Total;
  const t2Lead = t2Total > t1Total;
  const hasPairs = ts.matchRows.some(m => m.isPairs);
  const liveCnt  = ts.matchRows.filter(m => m.status !== 'finished').length;
  const doneCnt  = ts.matchRows.filter(m => m.status === 'finished').length;

  // â”€â”€ Team scoreline header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const leadingTeam = t1Lead ? ts.t1name : t2Lead ? ts.t2name : null;
  const leaderLbl   = leadingTeam ? `<span style="color:var(--gold);font-weight:700">ğŸ† ${leadingTeam} leading</span>` : `<span style="color:#ccc">All Square</span>`;

  const scoreline = `
    <div class="teams-header">
      <div class="teams-scoreline">
        <div class="team-block t1 ${t1Lead?'leading-t1':''}">
          <div class="team-lbl" style="color:var(--teal)">${ts.t1name}</div>
          <div class="team-pts" style="color:${t1Lead?'var(--teal)':'#ccc'}">${fmtPts(ts.t1pts + ts.halved * 0.5)}</div>
          <div class="team-record">${ts.t1pts}W Â· ${ts.halved}H</div>
        </div>
        <div class="score-divider">â€”</div>
        <div class="team-block t2 ${t2Lead?'leading-t2':''}">
          <div class="team-lbl" style="color:var(--red)">${ts.t2name}</div>
          <div class="team-pts" style="color:${t2Lead?'var(--red)':'#ccc'}">${fmtPts(ts.t2pts + ts.halved * 0.5)}</div>
          <div class="team-record">${ts.t2pts}W Â· ${ts.halved}H</div>
        </div>
      </div>
      <div class="teams-meta">
        ${leaderLbl}
        ${liveCnt ? `<span>â— <span style="color:var(--teal)">${liveCnt} live</span></span>` : ''}
        ${doneCnt ? `<span>âœ“ <span style="color:var(--gold)">${doneCnt} done</span></span>` : ''}
        <span style="margin-left:auto;color:#777">${ts.mode}${hasPairs?' Â· 4BBB':''}</span>
      </div>
    </div>`;

  // â”€â”€ Match cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const matchCards = ts.matchRows.map(m => {
    const done     = m.status === 'finished';
    const pct      = Math.round((m.hp / 18) * 100);
    const thruTxt  = done ? 'F' : m.hp === 0 ? 'Not started' : `Thru ${m.hp}`;

    // Card accent class â€” use winner colour when done, gold only for halved
    const cardCls  = done ? (m.resCls === 't1' ? 'mc-t1' : m.resCls === 't2' ? 'mc-t2' : 'mc-done') : m.resCls === 't1' ? 'mc-t1' : m.resCls === 't2' ? 'mc-t2' : 'mc-as';

    // Result badge â€” use winner colour when done, gold only for halved
    const badgeCls = done ? (m.resCls === 't1' ? 'mrbg-t1' : m.resCls === 't2' ? 'mrbg-t2' : 'mrbg-done') : m.resCls === 't1' ? 'mrbg-t1' : m.resCls === 't2' ? 'mrbg-t2' : 'mrbg-as';
    const resultTxt = m.resultLabel || 'AS';

    // Leading team name under badge (for live matches)
    const leadName = !done && m.resCls === 't1' ? ts.t1name : !done && m.resCls === 't2' ? ts.t2name : null;
    const leadHtml = leadName
      ? `<div class="match-leading" style="color:${m.resCls==='t1'?'var(--teal)':'var(--red)'}">${leadName} leads</div>`
      : done ? `<div class="match-leading" style="color:${m.resCls==='t1'?'var(--teal)':m.resCls==='t2'?'var(--red)':'var(--gold)'}">${m.resCls==='t1'?ts.t1name:m.resCls==='t2'?ts.t2name:'Halved'} wins</div>`
             : `<div class="match-leading" style="color:#ccc">All Square</div>`;

    // Player name HTML
    const hlName = n => {
      if (!filterSearch) return n;
      const idx = n.toLowerCase().indexOf(filterSearch);
      if (idx === -1) return `<span style="opacity:.35">${n}</span>`;
      return n.slice(0,idx) + `<mark style="background:rgba(0,232,187,.25);color:var(--teal);border-radius:3px;padding:0 2px">${n.slice(idx,idx+filterSearch.length)}</mark>` + n.slice(idx+filterSearch.length);
    };
    const t1Html = m.t1players.map(n => `<div class="match-player">${hlName(n)}</div>`).join('');
    const t2Html = m.t2players.map(n => `<div class="match-player">${hlName(n)}</div>`).join('');

    // Status dot
    const statusDot = done
      ? `<span style="color:${m.resCls==='t1'?'var(--teal)':m.resCls==='t2'?'var(--red)':'var(--gold)'};font-size:10px;font-weight:700">âœ“ FINAL</span>`
      : `<span style="color:var(--teal);font-size:10px;font-weight:700;animation:blink 1.8s ease infinite">â— LIVE</span>`;

    return `
      <div class="match-card ${cardCls}">
        <div class="match-body">
          <div class="match-t1-names">${t1Html}</div>
          <div class="match-centre">
            <div class="match-num">Match ${m.matchNum}</div>
            <div class="match-result-badge ${badgeCls}">${resultTxt}</div>
            ${leadHtml}
            <div class="match-thru" style="color:#ccc">${thruTxt}</div>
            ${statusDot}
          </div>
          <div class="match-t2-names">${t2Html}</div>
        </div>
        <div class="match-footer"><div class="match-progress" style="width:${pct}%"></div></div>
      </div>`;
  }).join('');

  main.innerHTML = `
    <div class="t-title" style="margin-bottom:16px">
      <div class="t-name">${tLabel}</div>
    </div>
    ${scoreline}
    <div style="font-size:9px;font-weight:700;letter-spacing:2px;color:#777;text-transform:uppercase;margin-bottom:10px">Match Leaderboard</div>
    <div class="match-list">${matchCards}</div>`;
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIVE TABLE VIEW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderLive(modeFilter) {
  const main    = document.getElementById('main-content');
  const allEntries = parseEntries(modeFilter);

  if (!allEntries.length) {
    hideBanner();
    main.innerHTML = `<div class="state-msg"><div class="icon">ğŸ“­</div><h3>No scores yet</h3><p>Scores appear here once players complete holes.</p></div>`;
    updateFilterResultsBar(0, 0);
    return;
  }

  // Route by play type
  const isTeams = detectTeamPlay(allEntries);

  if (isTeams) {
    // Teams: filter by name only (no score sorting â€” match cards have fixed structure)

    const filtered = filterSearch
      ? allEntries.filter(e => e.name.toLowerCase().includes(filterSearch))
      : allEntries;
    updateFilterResultsBar(allEntries.length, filtered.length);
    renderTeamsLive(filtered, main, allEntries);
    return;
  } else {
    hideBanner();

  }

  // Apply filter + sort to individual entries
  const entries = applyFilterSort(allEntries);
  updateFilterResultsBar(allEntries.length, entries.length);

  if (!entries.length) {
    main.innerHTML = `<div class="state-msg"><div class="icon">ğŸ”</div><h3>No match</h3><p>No players match <strong style="color:var(--teal)">"${filterSearch}"</strong>.<br>Try a different name.</p></div>`;
    return;
  }

  // Individual play
  const tLabel    = entries[0].tLabel;
  const isMatchplay = entries[0].mode === 'matchplay';
  const activeCnt = entries.filter(e=>e.status==='active').length;
  const finCnt    = entries.filter(e=>e.status==='finished').length;

  // â”€â”€ Matchplay: Ryder Cupâ€“style match cards, one per game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (isMatchplay) {
    // Group entries by gameId â€” each game = one match card
    const games = {};
    entries.forEach(e => {
      // Key by gameId + matchIndex so Match1 and Match2 get separate cards
      const gkey = `${e.gameId}_m${e.matchIndex||1}`;
      if (!games[gkey]) games[gkey] = [];
      games[gkey].push(e);
    });

    const hlName = n => {
      if (!filterSearch) return n;
      const idx = n.toLowerCase().indexOf(filterSearch);
      if (idx === -1) return `<span style="opacity:.35">${n}</span>`;
      return n.slice(0,idx)
        + `<mark style="background:rgba(0,232,187,.25);color:var(--teal);border-radius:3px;padding:0 2px">${n.slice(idx,idx+filterSearch.length)}</mark>`
        + n.slice(idx+filterSearch.length);
    };

    let matchNum = 1;

    // Helper: render one 1v1 match card from two player entries
    const renderMatchCard = (p1e, p2e, mn) => {
      if (!p1e || !p2e) return '';
      const hp   = Math.max(p1e.holesPlayed || 0, p2e.holesPlayed || 0);
      const pct  = Math.round((hp / 18) * 100);
      const done = p1e.status === 'finished' || p2e.status === 'finished';
      const thru = done ? 'F' : hp === 0 ? 'Not started' : `Thru ${hp}`;

      const mpLeading = p1e.mpLeading || p2e.mpLeading || 0;
      const p1leads = mpLeading === 1;
      const p2leads = mpLeading === 2;
      const as      = mpLeading === 0;

      const anyStatus = p1e.mpStatus || p2e.mpStatus || '';
      const rawLabel  = anyStatus
        .replace(/ DOWN$/,'').replace(/^L /,'').replace(/^W /,'') || 'AS';
      const badgeTxt  = as && !done ? 'AS' : rawLabel || 'AS';

      const _idone = p1leads ? 'imc-p1' : p2leads ? 'imc-p2' : 'imc-done';
      const cardCls  = done ? _idone : p1leads ? 'imc-p1' : p2leads ? 'imc-p2' : 'imc-as';
      const _ibadge  = p1leads ? 'mrbg-t1' : p2leads ? 'mrbg-t2' : 'mrbg-done';
      const badgeCls = done ? _ibadge : p1leads ? 'mrbg-t1' : p2leads ? 'mrbg-t2' : 'mrbg-as';

      const winnerName = done ? (p1leads ? p1e.name : p2leads ? p2e.name : 'Halved') : null;
      const winnerCol  = done ? (p1leads ? 'var(--teal)' : p2leads ? 'var(--red)' : 'var(--gold)') : null;
      const leadHtml = winnerName
        ? `<div class="match-leading" style="color:${winnerCol}">${winnerName} wins</div>`
        : p1leads
          ? `<div class="match-leading" style="color:var(--teal)">${p1e.name} leads</div>`
          : p2leads
            ? `<div class="match-leading" style="color:var(--red)">${p2e.name} leads</div>`
            : `<div class="match-leading" style="color:#ccc">All Square</div>`;

      const finalCol  = p1leads ? 'var(--teal)' : p2leads ? 'var(--red)' : 'var(--gold)';
      const statusDot = done
        ? `<span style="color:${finalCol};font-size:10px;font-weight:700">âœ“ FINAL</span>`
        : `<span style="color:var(--teal);font-size:10px;font-weight:700;animation:blink 1.8s ease infinite">â— LIVE</span>`;

      return `
        <div class="ind-match-card ${cardCls}">
          <div class="ind-match-body">
            <div class="ind-player p1-side">
              <div class="ind-player-name">${hlName(p1e.name)}</div>
              <div class="ind-player-sub">${p1e.course||''}</div>
            </div>
            <div class="ind-match-centre">
              <div class="match-num">Match ${mn}</div>
              <div class="ind-result-badge ${badgeCls}">${badgeTxt}</div>
              ${leadHtml}
              <div class="match-thru" style="color:#ccc">${thru}</div>
              ${statusDot}
            </div>
            <div class="ind-player p2-side">
              <div class="ind-player-name">${hlName(p2e.name||'')}</div>
              <div class="ind-player-sub">${p2e.course||''}</div>
            </div>
          </div>
          <div class="ind-match-footer"><div class="ind-match-prog" style="width:${pct}%"></div></div>
        </div>`;
    };

    // Sort game groups so Match 1 always appears before Match 2
    const sortedGames = Object.entries(games)
      .sort(([ka],[kb]) => ka.localeCompare(kb))
      .map(([,v]) => v);

    const cards = sortedGames.map(players => {
      // Each group is already 1 match (2 players) thanks to gameId+matchIndex keying
      return renderMatchCard(players[0], players[1], matchNum++);
    }).join('');

    const totalMatches = sortedGames.length;
    main.innerHTML = `
      <div class="t-title">
        <div class="t-name">${tLabel}</div>
        <div class="t-meta">
          <span>â›³ ${totalMatches} match${totalMatches!==1?'es':''}</span>
          ${activeCnt?`<span style="color:var(--teal)">â— ${activeCnt} live</span>`:''}
          ${finCnt?`<span style="color:var(--gold)">âœ“ ${finCnt/2|0} done</span>`:''}
        </div>
      </div>
      <div class="ind-match-list">${cards}</div>`;
    return;
  }

  // â”€â”€ Stroke / Stableford: standard sortable table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let rows = '', rank = 1;
  entries.forEach((e, i) => {
    const rCls = rank===1?'r1':rank===2?'r2':rank===3?'r3':'rn';
    const pct  = Math.round((e.holesPlayed/18)*100);

    let sh;
    if (e.mode==='stableford') {
      sh = `<div class="score-big col-teal">${e.stabTotal}</div><div class="score-lbl">PTS</div>`;
    } else {
      const d  = e.netTotal - e.par;
      const sc = d < 0 ? 'col-teal' : d > 0 ? 'col-red' : 'col-grey';
      if (e.holesPlayed === 0) {
        sh = `<div class="score-big col-grey">â€”</div><div class="score-lbl">NOT STARTED</div>`;
      } else {
        const lbl = e.holesPlayed === 18 ? `NET ${e.netTotal}` : `NET ${e.netTotal} Â· Thru ${e.holesPlayed}`;
        sh = `<div class="score-big ${sc}">${d===0?'E':(d>0?'+':'')+d}</div><div class="score-lbl">${lbl}</div>`;
      }
    }

    let pips='';
    for (let h=1;h<=18;h++){
      const hd=e.holeData[`h${h}`];
      const prv=h>1?e.holeData[`h${h-1}`]:null;
      const g=hd&&prv?hd.grossTotal-prv.grossTotal:(hd&&h===1?hd.grossTotal:null);
      const nxt=h===e.holesPlayed+1&&e.status==='active';
      pips+=`<div class="pip ${hd?'scored':''} ${nxt?'next':''}"><span class="pip-n">${h}</span>${g!=null?g:''}</div>`;
    }

    const hlName = n => {
      if (!filterSearch || !n.toLowerCase().includes(filterSearch)) return n;
      return n.replace(new RegExp(filterSearch,'gi'), m => `<mark style="background:rgba(0,232,187,.25);color:var(--teal);border-radius:3px;padding:0 2px">${m}</mark>`);
    };

    rows += `
      <tr class="${i===0?'leader':''}" onclick="toggleDetail(${i})">
        <td><span class="rank-num ${rCls}">${rank}</span></td>
        <td>
          <div class="p-name">${hlName(e.name)}</div>
          <div class="p-sub">${e.course} Â· ${e.mode}</div>
        </td>
        <td class="r">${sh}</td>
        <td><div class="holes-wrap">
          <div class="holes-num ${e.holesPlayed===18?'done':''}">${e.holesPlayed}/18</div>
          <div class="holes-bar"><div class="holes-fill" style="width:${pct}%"></div></div>
        </div></td>
        <td class="r"><span class="badge ${e.status==='finished'?'badge-finished':'badge-live'}">${e.status==='finished'?'âœ“ Done':'â— Live'}</span></td>
      </tr>
      <tr><td colspan="5" style="padding:0">
        <div class="hole-detail" id="detail-${i}">
          <div style="font-size:10px;color:#777;margin-bottom:7px;letter-spacing:1px;font-weight:700">HOLE BY HOLE</div>
          <div class="hole-pips">${pips}</div>
        </div>
      </td></tr>`;

    if (i<entries.length-1){
      const nxt=entries[i+1];
      const tied=e.mode==='stableford'?e.stabTotal===nxt.stabTotal:e.netTotal===nxt.netTotal;
      if(!tied) rank=i+2;
    }
  });

  main.innerHTML = `
    <div class="t-title">
      <div class="t-name">${tLabel}</div>
      <div class="t-meta">
        <span>â›³ ${entries.length} player${entries.length!==1?'s':''}</span>
        ${activeCnt?`<span style="color:var(--teal)">â— ${activeCnt} active</span>`:''}
        ${finCnt?`<span style="color:var(--gold)">âœ“ ${finCnt} finished</span>`:''}
      </div>
    </div>
    <table class="lb-table" id="lb-table">
      <thead><tr>
        <th style="width:32px">#</th>
        <th class="sortable" id="th-name"   onclick="setSort('name')"  >Player <span class="th-sort-arrow" id="arr-name"></span></th>
        <th class="sortable r" id="th-score"  onclick="setSort('score')" >Score  <span class="th-sort-arrow" id="arr-score"></span></th>
        <th class="sortable r" id="th-holes"  onclick="setSort('holes')" style="width:68px">Holes <span class="th-sort-arrow" id="arr-holes"></span></th>
        <th class="sortable r" id="th-status" onclick="setSort('status')" style="width:74px">Status <span class="th-sort-arrow" id="arr-status"></span></th>
      </tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
  // Initialise all sort arrows now that headers are in the DOM
  setSort(filterSort);
}


// â”€â”€ View tab switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _activeTab = 'leaderboard';
window.switchTab = function(tab) {
  _activeTab = tab;
  document.querySelectorAll('.view-tab').forEach((b, i) => {
    b.classList.toggle('active', (i === 0 && tab === 'leaderboard') || (i === 1 && tab === 'graphs'));
  });
  document.getElementById('panel-leaderboard').classList.toggle('active', tab === 'leaderboard');
  document.getElementById('panel-graphs').classList.toggle('active', tab === 'graphs');
  document.getElementById('filter-bar').style.display = tab === 'leaderboard' ? '' : 'none';
  if (tab === 'graphs') { _rebuildMatchDropdown(); }
};

// â”€â”€ Match graph filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _mgFilter = 'all';
let _selectedMatchKey = '';

window.setMgFilter = function(f) {
  _mgFilter = f;
  ['all','live','finished'].forEach(v => {
    const el = document.getElementById(`mgf-${v === 'finished' ? 'done' : v}`);
    if (el) el.classList.toggle('active', v === f);
  });
  _rebuildMatchDropdown();
};

function _rebuildMatchDropdown() {
  const sel = document.getElementById('mg-match-select');
  if (!sel) return;
  const prev = sel.value;
  sel.innerHTML = '<option value="">â€” Select a match â€”</option>';
  const games = _buildGameList();
  games.filter(g => _mgFilter === 'all' || g.status === _mgFilter).forEach(g => {
    const opt = document.createElement('option');
    opt.value = g.key;
    opt.textContent = `${g.status === 'live' ? 'â— ' : 'âœ“ '} ${g.label}`;
    sel.appendChild(opt);
  });
  // Re-select if still valid
  if (prev && [...sel.options].some(o => o.value === prev)) {
    sel.value = prev;
  } else {
    _selectedMatchKey = '';
    document.getElementById('mg-content').innerHTML = '<div class="mg-empty"><div class="icon">ğŸ“ˆ</div><p>Select a match above to view its worm graph</p></div>';
  }
}

function _buildGameList() {
  const games = [];
  Object.entries(liveScores).forEach(([gameId, gd]) => {
    if (!gd || !gd._meta) return;
    const meta = gd._meta;
    const players = Object.entries(gd).filter(([k]) => k !== '_meta');
    if (!players.length) return;
    const t1 = meta.team1name || 'Team 1';
    const t2 = meta.team2name || 'Team 2';
    const mode = meta.mode || 'stroke';
    const isTeam = meta.team || false;  // true for 4BBB team games

    if (isTeam) {
      // â”€â”€ 4BBB team game: all 4 players = ONE match, T1=p1+p3, T2=p2+p4 â”€â”€â”€â”€â”€â”€
      // teamName field set per player tells us which side they're on
      const t1ps = [], t2ps = [];
      players.forEach(([name, pd]) => {
        let _tn = pd.teamName; if (!_tn) { for(let i=1;i<=18;i++){if(pd[`h${i}`]?.teamName){_tn=pd[`h${i}`].teamName;break;}} }
        if (_tn === t2) t2ps.push(name.replace(/_/g,' '));
        else t1ps.push(name.replace(/_/g,' ')); // default to T1 if unset
      });
      const label = `${t1ps.join(' & ')||t1}  vs  ${t2ps.join(' & ')||t2}`;
      games.push({
        key: `${gameId}_4bbb`,
        gameId, matchIndex: 1, isTeam: true,
        label, status: _normStatus(meta.status),
        t1name: t1, t2name: t2,
        t1ps, t2ps,
        players, mode, meta
      });

    } else if (!isTeam && (meta.playerCount >= 4)) {
      // â”€â”€ Dual singles (4-player non-team): two independent matches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const m1 = players.filter(([,pd]) => (pd.matchIndex||1) === 1);
      const m2 = players.filter(([,pd]) => pd.matchIndex === 2);
      if (m1.length) games.push({
        key: `${gameId}_m1`, gameId, matchIndex: 1, isTeam: false,
        label: `${m1[0]?.[0]?.replace(/_/g,' ')||'P1'} vs ${m1[1]?.[0]?.replace(/_/g,' ')||'P2'}`,
        status: _normStatus(meta.status),
        t1name: t1, t2name: t2,
        players: m1, mode, meta
      });
      if (m2.length) games.push({
        key: `${gameId}_m2`, gameId, matchIndex: 2, isTeam: false,
        label: `${m2[0]?.[0]?.replace(/_/g,' ')||'P3'} vs ${m2[1]?.[0]?.replace(/_/g,' ')||'P4'} (M2)`,
        status: _normStatus(meta.status),
        t1name: t1, t2name: t2,
        players: m2, mode, meta
      });

    } else {
      // â”€â”€ Standard 1v1 singles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      games.push({
        key: `${gameId}_m1`, gameId, matchIndex: 1, isTeam: false,
        label: `${players[0]?.[0]?.replace(/_/g,' ')||'P1'} vs ${players[1]?.[0]?.replace(/_/g,' ')||'P2'}`,
        status: _normStatus(meta.status),
        t1name: t1, t2name: t2,
        players, mode, meta
      });
    }
  });

  games.sort((a,b) => {
    if (a.status==='live' && b.status!=='live') return -1;
    if (b.status==='live' && a.status!=='live') return 1;
    return a.label.localeCompare(b.label);
  });
  return games;
}

// Normalise Firebase status: 'active' â†’ 'live', anything else â†’ 'finished'
function _normStatus(s) { return (s === 'finished') ? 'finished' : 'live'; }

window.onMatchSelect = function(key) {
  _selectedMatchKey = key;
  if (!key) {
    document.getElementById('mg-content').innerHTML = '<div class="mg-empty"><div class="icon">ğŸ“ˆ</div><p>Select a match above to view its worm graph</p></div>';
    return;
  }
  _renderMatchGraph(key);
};

function _renderMatchGraph(key) {
  const games = _buildGameList();
  const g = games.find(x => x.key === key);
  if (!g) return;

  // â”€â”€ Find reference player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // For 4BBB: p1+p3 = T1, p2+p4 = T2. All four players share the SAME 4BBB
  // match status. We read from a T1 player so UP = T1 winning (positive worm).
  // teamName field stored per hole tells us which side each player is on.
  // For singles: players[0] = T1 side, players[1] = T2 side.
  const t1Players = [], t2Players = [];
  g.players.forEach(([name, pd]) => {
    // Check first available hole data for teamName
    let _tn2 = pd.teamName; if (!_tn2) { for(let i=1;i<=18;i++){if(pd[`h${i}`]?.teamName){_tn2=pd[`h${i}`].teamName;break;}} }
    if (_tn2 && _tn2 === g.t2name) t2Players.push([name, pd]);
    else t1Players.push([name, pd]); // T1 or unset â†’ treat as T1
  });
  if (!t1Players.length) t1Players.push(g.players[0]);
  if (!t2Players.length && g.players.length > 1) t2Players.push(g.players[1]);

  // Use the T1 player with the most holes played as reference (most complete data)
  t1Players.sort((a, b) => (b[1].holesPlayed||0) - (a[1].holesPlayed||0));
  const refPlayer   = t1Players[0]?.[1];
  const holesPlayed = refPlayer?.holesPlayed || 0;

  // â”€â”€ Infer missing hole 18 for matches that went the full distance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If the match is finished, holesPlayed < 18, and the last status is X DOWN/UP
  // (not a mid-round close like 3&2), the 18th hole was played but not synced.
  // Extend the worm by repeating the last known position at hole 18.
  const lastSyncedHole = holesPlayed;
  const lastSyncedStatus = refPlayer?.[`h${lastSyncedHole}`]?.mpStatus || '';
  const isFullMatch = g.status === 'finished' &&
                      lastSyncedHole > 0 && lastSyncedHole < 18 &&
                      (lastSyncedStatus.includes(' DOWN') || lastSyncedStatus.includes(' UP')) &&
                      !lastSyncedStatus.startsWith('W ') && !lastSyncedStatus.startsWith('L ');
  const effectiveHoles = isFullMatch ? 18 : holesPlayed;
  // â”€â”€ Build hole-by-hole worm from mpStatus of the T1 reference player â”€â”€â”€â”€â”€â”€â”€â”€
  // mpStatus is written from each player's own perspective:
  //   T1 player: "2 UP" = T1 leads by 2, "3 DOWN" = T2 leads by 3
  //   (same convention for both 4BBB and singles)
  const wormData    = []; // +ve = T1 leading, -ve = T2 leading, 0 = A/S
  const holeResults = []; // 'W' / 'L' / 'H' / null per hole

  for (let h = 1; h <= 18; h++) {
    if (h > effectiveHoles) { wormData.push(null); holeResults.push(null); continue; }

    // For inferred hole 18 (not in Firebase), carry last known position as Halved
    if (h > lastSyncedHole) {
      const lastPos = wormData[wormData.length - 1] ?? 0;
      wormData.push(lastPos);
      holeResults.push('H'); // hole 18 was halved (neither side gained)
      continue;
    }

    const hd  = refPlayer[`h${h}`] || {};
    const st  = hd.mpStatus || '';
    let pos   = 0;

    if (st.includes('All Square') || st === '') {
      pos = 0;
    } else if (st.includes(' UP')) {
      pos = parseInt(st, 10);
    } else if (st.includes(' DOWN')) {
      pos = -parseInt(st, 10);
    } else if (st.startsWith('W ') || st.startsWith('L ')) {
      // Closed match â€” extract numeric margin from label e.g. "W 3&2" â†’ +3, "L 1UP" â†’ -1
      const isWin    = st.startsWith('W ');
      const numMatch = st.match(/(\d+)/);
      const margin   = numMatch ? parseInt(numMatch[1], 10) : 1;
      pos = isWin ? margin : -margin;
    }

    // Hole result: direction the worm moved this hole
    const prevRaw = wormData[h - 2] ?? 0;
    const prev    = prevRaw === null ? 0 : prevRaw;
    holeResults.push(pos > prev ? 'W' : pos < prev ? 'L' : 'H');
    wormData.push(pos);
  }

  // Clamp display values to Â±6 for readability
  const displayData = wormData.map(v =>
    v === null ? null : Math.max(-6, Math.min(6, v))
  );
  let lastRealIdx = -1;
  displayData.forEach((v, i) => { if (v !== null) lastRealIdx = i; });
  const playedDisplay = lastRealIdx + 1;

  // â”€â”€ Result badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const lastVal     = lastRealIdx >= 0 ? (displayData[lastRealIdx] ?? 0) : 0;
  const finalStatus = refPlayer?.[`h${holesPlayed}`]?.mpStatus || '';
  const isLive      = g.status === 'live' || g.status === 'active';
  let resultLabel = '', resultClass = 'done';
  if (isLive) {
    resultClass = 'live';
    resultLabel = finalStatus || 'Live';
  } else if (finalStatus.startsWith('W ')) {
    resultLabel = `${g.t1name} ${finalStatus.replace('W ', '')}`; resultClass = 't1win';
  } else if (finalStatus.startsWith('L ')) {
    resultLabel = `${g.t2name} ${finalStatus.replace('L ', '')}`; resultClass = 't2win';
  } else if (finalStatus.includes('Halved') || finalStatus.includes('All Square')) {
    resultLabel = 'Halved'; resultClass = 'halved';
  } else {
    resultLabel = finalStatus || 'â€”';
  }

  // â”€â”€ Display names â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // For 4BBB use pre-built t1ps/t2ps from _buildGameList; for singles derive from players
  const t1Names = (g.t1ps && g.t1ps.length)
    ? g.t1ps.join(' & ')
    : t1Players.map(([n]) => n.replace(/_/g,' ')).join(' & ') || g.t1name;
  const t2Names = (g.t2ps && g.t2ps.length)
    ? g.t2ps.join(' & ')
    : t2Players.map(([n]) => n.replace(/_/g,' ')).join(' & ') || g.t2name;
  const modeLbl   = g.isTeam ? '4BBB Matchplay' : 'Singles Matchplay';
  const borderCol = lastVal > 0 ? 'var(--teal)' : lastVal < 0 ? 'var(--red)' : 'var(--gold)';

  const svgWorm   = _buildWormSVG(
    displayData.slice(0, playedDisplay),
    holeResults.slice(0, playedDisplay),
    isLive,
    g.t1name,
    g.t2name
  );

  // Dynamic legend labels (team names instead of hardcoded ROW/AUS)
  const stripHtml = holeResults.map((res, i) => {
    const played = res !== null;
    const col = res==='W'?'var(--teal)':res==='L'?'var(--red)':res==='H'?'var(--gold)':'#111';
    return `<div class="mg-hole-dot" style="background:${col};border-color:${played?col:'#1e1e1e'};opacity:${played?0.85:0.3};color:${played?'#000':'#222'}">${i+1}</div>`;
  }).join('');

  document.getElementById('mg-content').innerHTML = `
    <div class="mg-card">
      <div class="mg-card-header" style="border-left:4px solid ${borderCol}">
        <div class="mg-matchlabel">${modeLbl} Â· ${g.t1name} vs ${g.t2name}</div>
        <div class="mg-players">
          <span class="mg-p1">${t1Names}</span>
          <span class="mg-vs">vs</span>
          <span class="mg-p2">${t2Names}</span>
          <span class="mg-badge ${resultClass}" style="margin-left:auto">${isLive?'<span style="font-size:9px">â— </span>':''}${resultLabel}</span>
        </div>
        <div style="font-size:10px;color:#aaa;margin-top:6px">Thru ${playedDisplay} holes${!isLive?' Â· Final':''}</div>
      </div>
      <div class="mg-graph-area">${svgWorm}</div>
      <div style="padding:4px 16px 8px;font-size:10px;color:#aaa">Worm graph â€” tracks match position hole by hole. â†‘ ${g.t1name} leading Â· â†“ ${g.t2name} leading</div>
      <div class="mg-hole-strip">${stripHtml}</div>
      <div class="mg-legend">
        <span><span class="mg-leg-dot" style="background:var(--teal)"></span>${g.t1name} wins hole</span>
        <span><span class="mg-leg-dot" style="background:var(--red)"></span>${g.t2name} wins hole</span>
        <span><span class="mg-leg-dot" style="background:var(--gold)"></span>Halved</span>
        <span><span class="mg-leg-dot" style="background:#333;border:1px solid #555;display:inline-block"></span>Not played</span>
      </div>
    </div>`;
}

function _buildWormSVG(data, results, isLive, t1name, t2name) {
  const W = 560, H = 200;
  const PAD = { top: 28, right: 24, bottom: 36, left: 40 };
  const iW = W - PAD.left - PAD.right, iH = H - PAD.top - PAD.bottom;
  const maxD = Math.max(3, ...data.filter(v=>v!==null).map(Math.abs), 1);
  const midY = PAD.top + iH / 2;
  // xS now maps 0â€“18: position 0 = left edge (origin), positions 1â€“18 = holes 1â€“18
  const xS = i => PAD.left + (i / 18) * iW;
  const yS = v => midY - (v / maxD) * (iH / 2);
  const holeCol = res => res==='W' ? '#00e8bb' : res==='L' ? '#ff5a5a' : '#e2b84a';

  // Build path points â€” hole i (0-indexed) maps to x position i+1
  const validPts = data.map((v, i) => v !== null ? { x: xS(i + 1), y: yS(v), v, res: results[i] } : null).filter(Boolean);
  if (!validPts.length) return '<svg viewBox="0 0 560 200" style="width:100%;height:auto"><text x="280" y="100" text-anchor="middle" fill="#aaa" font-family="sans-serif" font-size="14">No data yet</text></svg>';

  // Origin sits exactly at x position 0 â€” the left edge of the plot area
  const origin = { x: xS(0), y: midY };
  const allPts = [origin, ...validPts];

  // â”€â”€ Per-segment coloured lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const segments = allPts.slice(0,-1).map((p, i) => {
    const next = allPts[i+1];
    const col = next.res ? holeCol(next.res) : '#555';
    return `<line x1="${p.x.toFixed(1)}" y1="${p.y.toFixed(1)}" x2="${next.x.toFixed(1)}" y2="${next.y.toFixed(1)}" stroke="${col}" stroke-width="2.5" stroke-linecap="round"/>`;
  }).join('');

  // â”€â”€ Subtle fill â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fillD = allPts.map((p,i)=>`${i===0?'M':'L'}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ')
    + ` L${validPts[validPts.length-1].x.toFixed(1)},${midY} L${origin.x.toFixed(1)},${midY} Z`;

  const lastPt  = validPts[validPts.length-1];
  const lastCol = lastPt ? holeCol(lastPt.res) : '#e2b84a';
  const ticks   = [-maxD, -2, -1, 0, 1, 2, maxD].filter((v,i,a)=>a.indexOf(v)===i);

  const gridLines = ticks.map(v => {
    const y = yS(v);
    if (y < PAD.top-2 || y > H-PAD.bottom+2) return '';
    return `<line x1="${PAD.left}" y1="${y.toFixed(1)}" x2="${W-PAD.right}" y2="${y.toFixed(1)}" stroke="${v===0?'#3a3a3a':'#252525'}" stroke-width="${v===0?1.5:.5}"/>`;
  }).join('');

  // Vertical hole lines at positions 1â€“18 (holes), plus the half-9 divider after hole 9
  const holeLines = Array.from({length:18},(_,i)=>
    `<line x1="${xS(i+1).toFixed(1)}" y1="${PAD.top}" x2="${xS(i+1).toFixed(1)}" y2="${H-PAD.bottom}" stroke="${i===8?'#444':'#2a2a2a'}" stroke-width="${i===8?1.5:.5}"/>`
  ).join('');

  // Dots coloured by hole result
  const dots = validPts.map((p, i) => {
    const col = holeCol(p.res);
    return `<circle cx="${p.x.toFixed(1)}" cy="${p.y.toFixed(1)}" r="3.5" fill="${col}" stroke="#0a0a0a" stroke-width="1.5"/>`;
  }).join('');

  const liveRing = isLive && lastPt ? `<circle cx="${lastPt.x.toFixed(1)}" cy="${lastPt.y.toFixed(1)}" r="9" fill="none" stroke="${lastCol}" stroke-width="1.5" opacity="0.3"><animate attributeName="r" values="9;15;9" dur="1.5s" repeatCount="indefinite"/><animate attributeName="opacity" values="0.3;0;0.3" dur="1.5s" repeatCount="indefinite"/></circle>` : '';

  const yLabels = ticks.map(v => {
    const y = yS(v);
    if (y < PAD.top || y > H-PAD.bottom) return '';
    const lbl = v===0?'A/S':Math.abs(v);
    return `<text x="${PAD.left-5}" y="${(y+4).toFixed(1)}" text-anchor="end" fill="#fff" font-size="10" font-weight="700" font-family="sans-serif">${lbl}</text>`;
  }).join('');

  // X-axis labels: 0 at origin, then 1â€“18 for each hole
  const xLabels = [
    `<text x="${xS(0).toFixed(1)}" y="${H-PAD.bottom+14}" text-anchor="middle" fill="#fff" font-size="10" font-weight="700" font-family="sans-serif">0</text>`,
    ...Array.from({length:18},(_,i) =>
      `<text x="${xS(i+1).toFixed(1)}" y="${H-PAD.bottom+14}" text-anchor="middle" fill="${i<data.length&&data[i]!==null?'#fff':'#555'}" font-size="10" font-weight="700" font-family="sans-serif">${i+1}</text>`
    )
  ].join('');

  // FRONT 9 / BACK 9 labels â€” bold, teal-tinted
  const f9 = `<text x="${xS(4.5).toFixed(1)}" y="${PAD.top-10}" text-anchor="middle" fill="#ffffff" font-size="10" font-weight="700" font-family="sans-serif" letter-spacing="1">FRONT 9</text>`;
  const b9 = `<text x="${xS(13.5).toFixed(1)}" y="${PAD.top-10}" text-anchor="middle" fill="#ffffff" font-size="10" font-weight="700" font-family="sans-serif" letter-spacing="1">BACK 9</text>`;

  return `<svg viewBox="0 0 ${W} ${H}" style="width:100%;height:auto;display:block" id="worm-svg">
  <rect x="0" y="0" width="${W}" height="${H}" fill="transparent"/>
  ${gridLines}${holeLines}${f9}${b9}
  <path d="${fillD}" fill="#ffffff" opacity="0.02"/>
  ${segments}
  ${liveRing}${dots}${yLabels}${xLabels}
  <text x="14" y="${H/2}" text-anchor="middle" fill="#ffffff" font-size="10" font-weight="700" font-family="sans-serif" letter-spacing="1" transform="rotate(-90,14,${H/2})">POSITION</text>
  <text x="${W/2}" y="${H-3}" text-anchor="middle" fill="#ffffff" font-size="10" font-weight="700" font-family="sans-serif" letter-spacing="1">HOLE</text>
  <text x="${PAD.left+4}" y="${PAD.top+10}" fill="#00e8bb" font-size="9" font-weight="700" font-family="sans-serif" opacity="0.8">â–² ${t1name}</text>
  <text x="${PAD.left+4}" y="${H-PAD.bottom-5}" fill="#ff5a5a" font-size="9" font-weight="700" font-family="sans-serif" opacity="0.8">â–¼ ${t2name}</text>
</svg>`;
}

// Re-render graph tab when scores update
const _origRender = window.render || function(){};
window.render = function() {
  _origRender();
  if (_activeTab === 'graphs') {
    _rebuildMatchDropdown();
    if (_selectedMatchKey) _renderMatchGraph(_selectedMatchKey);
  }
};

// â”€â”€ 30-second auto-refresh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _autoRefreshTimer = null;
let _countdownTimer   = null;
let _nextRefreshAt    = 0;

function _updateCountdown() {
  const secs = Math.max(0, Math.ceil((_nextRefreshAt - Date.now()) / 1000));
  const el   = document.getElementById('refresh-countdown');
  if (!el) return;
  el.textContent = `${secs}s`;
  // Colour: teal when nearly due, muted otherwise
  el.style.color = secs <= 5 ? 'var(--teal)' : '#aaa';
}

function _silentRefresh() {
  if (!currentKey) return;
  // onValue subscriptions are already real-time â€” they fire automatically on every
  // Firebase change. Just re-render with the latest liveScores already in memory.
  // Only re-subscribe if the subscription was somehow lost (unsubScores is null).
  if (!unsubScores) {
    if (SGG_KEYS.includes(currentKey) && !unsubSibling) {
      const sibKey = currentKey === 'sgg_2026_day1' ? 'sgg_2026_day2' : 'sgg_2026_day1';
      unsubSibling = onValue(ref(db, `tournaments/${sibKey}/scores`), snap => {
        sggSiblingScores = snap.val() || {};
        renderSGGBanner();
      });
    }
    unsubScores = onValue(ref(db, `tournaments/${currentKey}/scores`), snap => {
      liveScores = snap.val() || {};
      render();
    });
  } else {
    // Subscription is live â€” just force a render with current data
    render();
  }
}

function _startAutoRefresh() {
  _stopAutoRefresh();
  _nextRefreshAt = Date.now() + 30000;
  _updateCountdown();

  _autoRefreshTimer = setInterval(() => {
    _silentRefresh();
    _nextRefreshAt = Date.now() + 30000;
    // Flash âœ“ briefly to confirm refresh fired
    const el = document.getElementById('refresh-countdown');
    if (el) { el.style.color = 'var(--teal)'; el.textContent = 'âœ“'; }
    setTimeout(() => _updateCountdown(), 600);
  }, 30000);

  _countdownTimer = setInterval(_updateCountdown, 1000);
}

function _stopAutoRefresh() {
  if (_autoRefreshTimer) { clearInterval(_autoRefreshTimer); _autoRefreshTimer = null; }
  if (_countdownTimer)   { clearInterval(_countdownTimer);   _countdownTimer   = null; }
}

// Start auto-refresh once a tournament is loaded
_startAutoRefresh();

// Hole detail toggle
window.toggleDetail = function(i) {
  const el = document.getElementById('detail-'+i);
  if (el) el.classList.toggle('open');
};

// Auto-select from URL param
const urlP = new URLSearchParams(window.location.search);
const tP = urlP.get('t');
const _backUrl = urlP.get('back') || 'index.html';
window.goBack = function() {
  // Flag already set by index.html before navigating here
  // Just navigate back â€” index.html will detect flag and go to scorecard
  const base = window.location.href.replace(/[^\/]*(\?.*)?$/, '');
  window.location.href = base + 'index.html';
};
if (tP) {
  setTimeout(() => {
    const sel = document.getElementById('t-select');
    sel.value = tP;
    if (sel.value === tP) window.onTournamentChange(tP);
  }, 1500);
}
</script>

<!-- Watermark footer -->
<div class="hf-watermark" style="text-align:center;padding:24px 16px 32px;border-top:1px solid #141414;margin-top:12px">
  <div style="display:inline-flex;align-items:center;gap:8px;opacity:0.5">
    <svg width="18" height="18" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
      <circle cx="20" cy="20" r="20" fill="#00e8bb" fill-opacity="0.15"/>
      <text x="20" y="26" text-anchor="middle" font-size="18" font-weight="900" fill="#00e8bb" font-family="serif">H</text>
    </svg>
    <span style="font-family:'DM Sans',sans-serif;font-size:11px;font-weight:700;letter-spacing:1.5px;color:#00e8bb">POWERED BY HILLFRED</span>
  </div>
</div>

</body>
</html>
